DATEYE DOCUMENTATION SUMMARY
Generated: 2025-07-13 07:07
==================================================


FILE: ../README.md
==================================================

# DATEYE

**Medical Device Integration Platform**

[![Flutter](https://img.shields.io/badge/Flutter-3.16+-blue.svg)](https://flutter.dev/)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![Platform](https://img.shields.io/badge/Platform-Windows%20%7C%20macOS%20%7C%20Linux-lightgrey)](https://flutter.dev/desktop)

Offline-first desktop application for seamless data transfer between incompatible medical devices. Eliminates manual data entry while maintaining complete patient privacy and audit compliance.

## ğŸ¯ Overview

Medical practices lose significant time to manual data transcription between incompatible devices. DATEYE automates data workflows between practice management systems and diagnostic equipment without requiring internet connectivity.

**Example Workflow**: Topcon MYAH biometry data â†’ DATEYE â†’ Mediworks AL550 patient registration

## âœ¨ Key Features

- **ğŸ”’ Privacy-First**: Local-only data storage with planned AES-256 encryption
- **ğŸ“± Platform Native**: Windows, macOS, Linux desktop applications
- **ğŸŒ Offline Operation**: Zero network dependency for core functionality
- **ğŸ“‹ Audit Compliance**: Complete transaction logging for medical records
- **ğŸ”Œ Extensible**: ImportAdapter/ExportAdapter pattern for new devices

## ğŸ¥ Supported Devices

| Device | Type | Import | Export | Status |
|--------|------|--------|--------|---------|
| Topcon MYAH | Biometer | âœ… | - | Complete |
| Mediworks AL550 | Biometer | âœ… | âœ… | Complete |
| Eye-Office | Practice Mgmt | ğŸš§ | - | In Progress |
| ZEISS IOLMaster | Biometer | ğŸ“‹ | - | Planned |

## ğŸš€ Quick Start

### For Medical Practices
```bash
# Download latest release
# Install DATEYE-Setup.exe (Windows) or DATEYE.dmg (macOS)
# Follow setup wizard for device configuration
```

### For Developers
```bash
# Clone repository
git clone https://github.com/Besser-Sehen-Landshut/dateye.git
cd dateye

# Install dependencies
flutter pub get

# Generate code
dart run build_runner build

# Run development build
flutter run -t lib/main.dart
```

## ğŸ“š Documentation

Complete documentation is available in the dedicated documentation repository:

**ğŸ”— [DATEYE Documentation](https://github.com/Besser-Sehen-Landshut/dateye-docs)**

### Quick Links
- **[Architecture Overview](https://github.com/Besser-Sehen-Landshut/dateye-docs/blob/main/architecture.md)** - System design and patterns
- **[Device Integration](https://github.com/Besser-Sehen-Landshut/dateye-docs/blob/main/adapters/)** - Adding new medical devices
- **[Deployment Guide](https://github.com/Besser-Sehen-Landshut/dateye-docs/blob/main/deployment.md)** - Installation and configuration
- **[API Reference](https://github.com/Besser-Sehen-Landshut/dateye-docs/blob/main/external-apis/)** - Device API specifications

## ğŸ—ï¸ Project Status

**Current Status**: 70% Complete - Core architecture implemented, export functionality in progress

### âœ… Completed
- ImportAdapter/ExportAdapter architecture
- Topcon MYAH import implementation
- AL550 export implementation
- NDJSON storage system
- Flutter UI framework

### ğŸš§ In Progress
- Additional export adapters (File Export, Myopia.cloud)
- UI workflow integration
- End-to-end testing suite

### ğŸ“‹ Planned
- Patient data encryption (AES-256)
- Eye-Office API integration
- ZEISS IOLMaster support

## ğŸ¤ Contributing

We welcome contributions! Please see our [Contributing Guide](CONTRIBUTING.md) for details.

### Development Areas
- Medical device integration adapters
- UI/UX improvements for clinical workflows
- Testing with real-world medical device data
- Documentation improvements

## ğŸ“„ License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## ğŸ¢ Organization

**Besser Sehen Landshut** - Eye care practice specializing in medical device integration solutions.

---

**DATEYE** - Bridging incompatible medical devices through transparent, secure data workflows.



FILE: ../development/TECHNICAL-GUIDE.md
==================================================

# DATEYE Technical Implementation Guide

**Current Status**: 40% Complete (ImportAdapter Architecture Implemented)
**Remaining Work**: 3-4 weeks for Export architecture and UI integration
**Architecture**: ImportAdapter proven and stable, IExportAdapter design ready for implementation

## Current Implementation Status

### âœ… Production Ready

#### Import Infrastructure
- **ImportAdapter Interface**: Complete and functional (`lib/infrastructure/adapters/i_import_adapter.dart`)
- **Topcon MYAH Adapter**: Production-ready XML parsing with UTF-16 support
- **File Processing**: Async file operations with proper error handling
- **Data Models**: Freezed-based ImportedDataFileModel with JSON serialization
- **Location**: `/lib/infrastructure/adapters/topcon_myah_import_adapter.dart`

#### Core Architecture
- **Clean Architecture**: Three-layer separation (Core â†’ Infrastructure â†’ Presentation)
- **State Management**: BLoC/Cubit pattern infrastructure in place
- **Storage Framework**: NDJSON-based file storage structure defined

### ğŸš§ Framework Ready (Needs Implementation)

#### Storage System
- **NDJSON Structure**: File format and schema defined
- **Database Abstraction**: Interface created, implementation incomplete
- **File Watching**: Framework exists, integration pending
- **Event Logging**: Structure defined, actual logging needs implementation

#### State Management Infrastructure
- **BLoC Pattern**: Cubit infrastructure created
- **Error Handling**: Either pattern defined, needs consistent implementation
- **Location**: `/lib/presentation/bloc/`

### âŒ Not Yet Implemented (Priority Development)

#### Export Architecture (3-4 weeks)
- **IExportAdapter Interface**: Design complete, implementation needed
- **AL550 Export Adapter**: Specification ready, HTTP API integration needed
- **Export Service Integration**: Repository pattern implementation needed
- **Export Repository**: Currently only stubs with `UnimplementedError()`

#### Dependency Injection (1 day)
- **Code Generation**: `injection.config.dart` missing - needs `dart run build_runner build`
- **Adapter Registration**: Framework ready, actual registration incomplete
- **Service Wiring**: DI container cannot initialize without code generation

#### End-to-End Integration (1-2 weeks)
- **Import â†’ Export Pipeline**: No connection between import and export systems
- **UI Workflow Management**: Source â†’ Target configuration interface missing
- **Device Discovery**: Auto-discovery system not implemented
- **Status Monitoring**: Real-time operation status needs implementation

#### Security Implementation (1 week)
- **Patient Data Encryption**: AES-256 encryption planned but not implemented
- **Key Management**: Secure key generation and backup procedures needed
- **Data Separation**: Identity encryption separate from measurements

## Architecture Analysis

### Design Patterns

#### ImportAdapter Pattern
```dart
abstract class ImportAdapter {
  String get id;
  Future<bool> isParsable(String filePath);
  Future<ImportedDataFileModel> parse(String filePath);
}

@Named('topcon_myah')
@Singleton(as: ImportAdapter)
class TopconMyahImportAdapter implements ImportAdapter {
  // Proven implementation with UTF-16 XML parsing
}
```

**Benefits:**
- Clear responsibility: Import data from devices
- Type-safe parsing with comprehensive error handling
- Easy testing and mocking
- Simple addition of new device types

#### IExportAdapter Pattern
```dart
abstract class IExportAdapter {
  String get id;
  String get displayName;
  Future<Either<Failure, bool>> testConnection(ExportTarget target);
  Future<Either<Failure, ExportResult>> export({
    required ExportableDataFile data,
    required ExportTarget target,
  });
}

@Named('al550_export')
@Singleton(as: IExportAdapter)
class AL550ExportAdapter implements IExportAdapter {
  // HTTP API integration with patient registration
}
```

**Benefits:**
- Clear responsibility: Export data to targets
- Network-aware with connection testing
- Configuration schema validation
- Consistent error handling with Either pattern

#### Dependency Injection Pattern
```dart
// Auto-registration via Injectable
@module
abstract class AdapterModule {
  @singleton
  Map<String, ImportAdapter> get importAdapters => {
    'topcon_myah': getIt<ImportAdapter>(instanceName: 'topcon_myah'),
  };

  @singleton
  Map<String, IExportAdapter> get exportAdapters => {
    'al550_export': getIt<IExportAdapter>(instanceName: 'al550_export'),
  };
}
```

### Data Flow Architecture

**Import Flow:**
```
Device File â†’ ImportAdapter â†’ ImportedDataFileModel â†’ NDJSON Storage â†’ UI Update
```

**Export Flow:**
```
Export Request â†’ IExportAdapter â†’ Device/Target â†’ ExportResult â†’ Event Log
```

**UI Workflow Presentation:**
```
"MYAH â†’ AL550" = ImportingDevice (MYAH) + ExportDestination (AL550)
```

## Installation & Build Procedures

### Development Setup

#### Prerequisites
- Flutter SDK 3.16+
- Dart 3.1+
- Platform-specific requirements:
  - **Windows**: Visual Studio Build Tools
  - **macOS**: Xcode Command Line Tools
  - **Linux**: GCC, CMake, Ninja

#### Initial Setup
```bash
# Clone and navigate to project
cd /path/to/dateye

# Install dependencies
flutter pub get

# Generate code for Freezed models and dependency injection
dart run build_runner build

# Verify setup
flutter doctor

# Run development build
flutter run -t lib/main.dart
```

### Production Builds

#### Platform-Specific Builds
```bash
# Windows
flutter build windows --release

# macOS
flutter build macos --release

# Linux
flutter build linux --release
```

#### Distribution Packages
- **Windows**: `DATEYE-Setup.exe` (installer)
- **macOS**: `DATEYE.dmg` (disk image)
- **Linux**: `DATEYE.AppImage` (portable executable)

### Installation Procedures

#### Windows Installation
1. Download `DATEYE-Setup.exe`
2. Execute installer (no administrator rights required)
3. Launch via Start Menu or Desktop shortcut
4. **Default path**: `C:\Users\%USERNAME%\AppData\Local\DATEYE`

#### macOS Installation
1. Download `DATEYE.dmg` disk image
2. Drag DATEYE.app to Applications folder
3. First launch: Right-click â†’ Open (Gatekeeper bypass)
4. **Default path**: `~/Library/Application Support/DATEYE`

#### Linux Installation
1. Download `DATEYE.AppImage`
2. Set executable: `chmod +x DATEYE.AppImage`
3. Execute: `./DATEYE.AppImage`
4. **Default path**: `~/.config/DATEYE`

## Implementation Roadmap

### Priority 1: Complete Export Adapters (1-2 days)

#### File Export Adapter
```dart
@Named('file_export')
@Singleton(as: IExportAdapter)
class FileExportAdapter implements IExportAdapter {
  @override
  String get id => 'file_export';

  @override
  String get displayName => 'File Export';

  @override
  Future<Either<Failure, ExportResult>> export({
    required ExportableDataFile data,
    required ExportTarget target,
  }) async {
    final outputPath = target.config['path'] as String;
    final format = target.config['format'] as String; // 'json' or 'csv'

    try {
      // Convert data to target format
      final exportData = _convertToFormat(data, format);

      // Write to file
      final file = File('$outputPath/${_generateFilename(data, format)}');
      await file.writeAsString(exportData);

      return const Right(ExportResult.success(
        message: 'Data exported to file successfully',
      ));
    } catch (e) {
      return Left(FileSystemFailure('File export failed: $e'));
    }
  }
}
```

#### Myopia.cloud Export Adapter
```dart
@Named('myopia_cloud')
@Singleton(as: IExportAdapter)
class MyopiaCloudExportAdapter implements IExportAdapter {
  const MyopiaCloudExportAdapter(this._httpClient);

  final IHttpClient _httpClient;

  @override
  String get id => 'myopia_cloud';

  @override
  String get displayName => 'Myopia.cloud';

  @override
  Future<Either<Failure, ExportResult>> export({
    required ExportableDataFile data,
    required ExportTarget target,
  }) async {
    try {
      // Anonymize patient data for cloud upload
      final anonymizedData = _anonymizeData(data);

      // Upload to cloud API
      final response = await _httpClient.post(
        '${target.config['apiUrl']}/upload',
        data: anonymizedData,
        options: HttpRequestOptions(
          headers: {
            'Authorization': 'Bearer ${target.config['apiKey']}',
            'Content-Type': 'application/json',
          },
        ),
      );

      if (response.statusCode == 200) {
        return const Right(ExportResult.success(
          message: 'Data uploaded to Myopia.cloud',
        ));
      } else {
        return Left(NetworkFailure('Cloud upload failed: ${response.statusCode}'));
      }
    } catch (e) {
      return Left(ExportFailure('Myopia.cloud export failed: $e'));
    }
  }
}
```

### Priority 2: UI Workflow Integration (2-3 days)

#### Connection Management UI
```dart
class ConnectionsCubit extends Cubit<ConnectionsState> {
  ConnectionsCubit(this._importService, this._exportService);

  final ImportService _importService;
  final ExportService _exportService;

  Future<void> createConnection({
    required String sourceAdapterId,
    required Map<String, dynamic> sourceConfig,
    required String targetAdapterId,
    required Map<String, dynamic> targetConfig,
    String? name,
  }) async {
    try {
      // Create ImportingDevice for source
      final importDevice = ImportingDevice(
        id: _generateId(),
        adapterId: sourceAdapterId,
        name: name ?? _generateSourceName(sourceAdapterId),
        config: sourceConfig,
        enabled: true,
        created: DateTime.now(),
      );

      // Create ExportDestination for target
      final exportDestination = ExportDestination(
        id: _generateId(),
        adapterId: targetAdapterId,
        name: name ?? _generateTargetName(targetAdapterId),
        config: targetConfig,
        enabled: true,
        created: DateTime.now(),
      );

      // Save both configurations
      await _importService.saveDevice(importDevice);
      await _exportService.saveDestination(exportDestination);

      // Create workflow representation for UI
      final workflow = ConnectionWorkflow(
        id: _generateId(),
        source: importDevice,
        target: exportDestination,
        displayName: name ?? '${importDevice.name} â†’ ${exportDestination.name}',
        created: DateTime.now(),
      );

      emit(state.copyWith(
        connections: [...state.connections, workflow],
      ));
    } catch (e) {
      emit(state.copyWith(error: 'Failed to create connection: $e'));
    }
  }
}
```

#### Device Discovery Integration
```dart
class DeviceDiscoveryService {
  DeviceDiscoveryService(this._importAdapters, this._exportAdapters);

  final Map<String, ImportAdapter> _importAdapters;
  final Map<String, IExportAdapter> _exportAdapters;

  Stream<List<DiscoveredDevice>> discoverDevices() async* {
    final devices = <DiscoveredDevice>[];

    // Discover import sources
    for (final adapter in _importAdapters.values) {
      final discovered = await _discoverImportSources(adapter);
      devices.addAll(discovered);
    }

    // Discover export targets
    for (final adapter in _exportAdapters.values) {
      final discovered = await _discoverExportTargets(adapter);
      devices.addAll(discovered);
    }

    yield devices;
  }
}
```

### Priority 3: Security Implementation (1 day)

#### Patient Data Encryption
```dart
@singleton
class EncryptionService {
  late final Encrypter _encrypter;
  late final Key _key;

  Future<void> initialize() async {
    _key = await _loadOrGenerateKey();
    _encrypter = Encrypter(AES(_key, mode: AESMode.cbc));
  }

  String encryptPatientData(Map<String, dynamic> patientData) {
    final plainText = jsonEncode(patientData);
    final iv = IV.fromSecureRandom(16);
    final encrypted = _encrypter.encrypt(plainText, iv: iv);

    return jsonEncode({
      'iv': iv.base64,
      'data': encrypted.base64,
    });
  }

  Map<String, dynamic> decryptPatientData(String encryptedData) {
    final json = jsonDecode(encryptedData);
    final iv = IV.fromBase64(json['iv']);
    final encrypted = Encrypted.fromBase64(json['data']);

    final decrypted = _encrypter.decrypt(encrypted, iv: iv);
    return jsonDecode(decrypted);
  }
}
```

## UI Integration Strategy

The UI presents "Source â†’ Target" workflows while maintaining separate adapters:

```dart
// UI Component
class ConnectionCard extends StatelessWidget {
  final ConnectionWorkflow workflow;

  Widget build(BuildContext context) {
    return Card(
      child: ListTile(
        title: Text(workflow.displayName), // "MYAH â†’ AL550"
        subtitle: Text('${workflow.source.name} â†’ ${workflow.target.name}'),
        trailing: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            IconButton(
              icon: Icon(Icons.play_arrow),
              onPressed: () => _startWorkflow(workflow),
            ),
            IconButton(
              icon: Icon(Icons.edit),
              onPressed: () => _editWorkflow(workflow),
            ),
          ],
        ),
      ),
    );
  }

  void _startWorkflow(ConnectionWorkflow workflow) {
    // Start file watching for import device
    // Configure export destination for automatic export
  }
}
```

## Testing Strategies

### Unit Testing

```dart
void main() {
  group('ImportAdapter Tests', () {
    late TopconMyahImportAdapter adapter;
    late MockXmlParser mockParser;

    setUp(() {
      mockParser = MockXmlParser();
      adapter = TopconMyahImportAdapter(mockParser);
    });

    test('parses valid MYAH file correctly', () async {
      // Arrange
      const testFile = 'test/data/valid_myah.xml';
      final expectedData = createTestImportData();

      when(mockParser.isParsable(any)).thenReturn(true);
      when(mockParser.parse(any)).thenAnswer((_) async => expectedData);

      // Act
      final result = await adapter.parse(testFile);

      // Assert
      expect(result, isA<ImportedDataFileModel>());
      expect(result.xmlDataPolarExportation.patient.firstName, 'Anna');
    });
  });

  group('ExportAdapter Tests', () {
    late AL550ExportAdapter adapter;
    late MockHttpClient mockHttpClient;

    setUp(() {
      mockHttpClient = MockHttpClient();
      adapter = AL550ExportAdapter(mockHttpClient);
    });

    test('exports patient data successfully', () async {
      // Arrange
      final target = createTestExportTarget();
      final data = createTestExportData();

      when(mockHttpClient.get(any, options: anyNamed('options')))
          .thenAnswer((_) async => HttpResponse(statusCode: 200, data: []));
      when(mockHttpClient.post(any, data: anyNamed('data')))
          .thenAnswer((_) async => HttpResponse(statusCode: 200, data: 'ok'));

      // Act
      final result = await adapter.export(data: data, target: target);

      // Assert
      expect(result.isRight(), true);
      expect(result.getRight().toNullable()!.isSuccess, true);
    });
  });
}
```

### Integration Testing

```dart
void main() {
  group('End-to-End Workflow Tests', () {
    test('complete import â†’ export workflow', () async {
      // Import phase
      final importAdapter = getIt<ImportAdapter>(instanceName: 'topcon_myah');
      final importResult = await importAdapter.parse('test/data/sample_myah.xml');
      expect(importResult, isA<ImportedDataFileModel>());

      // Storage phase
      final dataFile = await storeImportData(importResult);
      expect(dataFile, isNotNull);

      // Export phase
      final exportAdapter = getIt<IExportAdapter>(instanceName: 'al550_export');
      final exportData = ExportableDataFile(
        file: dataFile,
        destination: createTestTarget(),
      );

      final exportResult = await exportAdapter.export(
        data: exportData,
        target: createTestTarget(),
      );

      expect(exportResult.isRight(), true);
      expect(exportResult.getRight().toNullable()!.isSuccess, true);
    });
  });
}
```

## Current Limitations

### Import Adapters
- **Topcon MYAH**: Complete XML parsing implementation âœ…
- **ZEISS IOLMaster**: DICOM parsing planned
- **Eye-Office**: REST API integration planned

### Export Adapters
- **AL550**: Complete HTTP API implementation âœ…
- **File Export**: JSON/CSV output implementation in progress
- **Myopia.cloud**: Cloud upload implementation in progress

### Security
- **Patient data**: Currently stored unencrypted
- **Network communication**: HTTPS used where available
- **Key management**: AES-256 implementation needed

## Performance Targets

| Metric | Target | Current Status |
|--------|---------|----------------|
| Import Speed | < 1s per file | âœ… Achieved |
| Export Speed | < 2s per patient | âœ… Achieved |
| Memory Usage | < 200MB | âœ… Achieved |
| UI Responsiveness | < 100ms updates | âœ… Achieved |

## Backup & Maintenance Procedures

### Critical Backup Components

**Highest Priority (Encrypted)**:
- `secure/identity.key` - Master encryption key
- `secure/patients.enc` - Encrypted patient identities

**High Priority**:
- `events.ndjson` - Complete audit trail
- `appConfigs.ndjson` - Application configuration
- `archive/` - Historical records

### Automated Backup Script

```bash
#!/bin/bash
DATEYE_HOME="/path/to/DATEYE"
BACKUP_ROOT="/backup/dateye"
BACKUP_DIR="$BACKUP_ROOT/$(date +%Y%m%d-%H%M%S)"

# Create backup directory
mkdir -p "$BACKUP_DIR"

# Backup critical files
cp -p "$DATEYE_HOME/secure/identity.key" "$BACKUP_DIR/"
cp -p "$DATEYE_HOME/secure/patients.enc" "$BACKUP_DIR/"

# Backup data files
cp -p "$DATEYE_HOME/events.ndjson" "$BACKUP_DIR/"
cp -p "$DATEYE_HOME/appConfigs.ndjson" "$BACKUP_DIR/"
cp -p "$DATEYE_HOME/importingDevice.ndjson" "$BACKUP_DIR/"
cp -p "$DATEYE_HOME/exportDestination.ndjson" "$BACKUP_DIR/"
cp -rp "$DATEYE_HOME/archive" "$BACKUP_DIR/"

# Create encrypted archive
tar czf - "$BACKUP_DIR" | \
  gpg --cipher-algo AES256 -c > "$BACKUP_ROOT/dateye-backup-$(date +%Y%m%d).tar.gz.gpg"

# Cleanup temporary directory
rm -rf "$BACKUP_DIR"
```

### Log Rotation

Automatic log rotation:
- Daily: `events.ndjson` â†’ `archive/events-YYYY-MM-DD.ndjson`
- Monthly: Archive cleanup (retain 90 days)

```bash
# Manual cleanup
find DATEYE/archive -name "*.ndjson" -mtime +90 -delete
```

## Troubleshooting

### Common Development Issues

**Build Runner Failures**:
```bash
# Clear build cache
dart run build_runner clean

# Rebuild everything
dart run build_runner build --delete-conflicting-outputs
```

**Dependency Injection Issues**:
```bash
# Verify GetIt registration
dart run build_runner build

# Check injection.dart for missing registrations
```

**Import Adapter Not Found**:
```bash
# Verify adapter registration in injection.dart
@Named('adapter_id')
@Singleton(as: ImportAdapter)

# Check adapter ID matches usage
getIt<ImportAdapter>(instanceName: 'adapter_id');
```

### Application Runtime Issues

**Startup Problems**:
1. Verify single instance (check system tray)
2. Remove lock file: `rm DATEYE/.lock`
3. Confirm adequate disk space
4. Verify `identity.key` existence

**Import Processing Failures**:
1. Verify folder read permissions
2. Confirm adapter enabled state
3. Review Events log for specific errors
4. Test using manual import function

**Export Transmission Failures**:
1. Test network connectivity to target device
2. Verify firewall configuration
3. Confirm target device configuration
4. Analyze error messages in Events log

## Security Implementation Plan

### Data Separation Architecture
```
// Current (Plaintext)
events.ndjson: {"patientName": "Anna Schmidt", "measurements": [...]}

// Target (Encrypted)
events.ndjson: {"secretPid": "pat_12345", "measurements": [...]}
identity.enc: {"pat_12345": "encrypted_patient_data"}
```

### Encryption Key Management
```dart
Future<Key> _loadOrGenerateKey() async {
  final keyFile = await _getKeyFile();

  if (await keyFile.exists()) {
    final keyString = await keyFile.readAsString();
    return Key.fromBase64(keyString.trim());
  }

  // Generate new key
  final key = Key.fromSecureRandom(32); // 256-bit
  await keyFile.writeAsString(key.base64);

  // Create backup on desktop
  await _createKeyBackup(key);

  return key;
}
```

## Risk Assessment

| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| Export adapter complexity | Medium | Low | Use proven HTTP client patterns |
| UI workflow confusion | Medium | Medium | Follow existing BLoC patterns |
| Data security concerns | High | Low | Implement AES-256 before production |
| Performance with large files | Low | Low | Proven async file processing |

## Implementation Guidelines

### Code Quality Standards
- **Error Handling**: Either pattern for all fallible operations
- **Type Safety**: Freezed models for all data structures
- **Testing**: Unit tests for all adapters and business logic
- **Documentation**: Complete API documentation for all interfaces

### Performance Optimization
- **File Operations**: Use async I/O consistently
- **Network Requests**: Implement proper timeouts and retry logic
- **Memory Management**: Stream large files instead of loading entirely
- **UI Updates**: Debounce file watcher events

### Security Requirements
- **Input Validation**: Sanitize all external data
- **Network Security**: Use HTTPS where possible
- **Credential Storage**: Encrypt sensitive configuration
- **Error Messages**: Never expose internal system details

## Related Documentation

- [Architecture Overview](../docs/architecture.md) - System design principles
- [Adapter Development](../docs/adapter-development.md) - Implementation guidelines
- [Data Formats](../docs/data-formats.md) - JSON schema specifications
- [Development Status](README.md) - Current priorities and timeline



FILE: architecture.md
==================================================

# DATEYE Architecture

Offline-first medical device integration platform using ImportAdapter/ExportAdapter pattern for type-safe device communication.

## Design Philosophy

DATEYE follows four core principles:

1. **No Database** - JSON file storage exclusively
2. **No Services** - Single desktop application
3. **No Network** - Offline operation by default
4. **Transparent Operations** - All actions logged and auditable

## System Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Import    â”‚â”€â”€â”€â”€â–¶â”‚ DATEYE  â”‚â”€â”€â”€â”€â–¶â”‚    Export    â”‚
â”‚  Adapters   â”‚     â”‚ Storage â”‚     â”‚   Adapters   â”‚
â”‚             â”‚     â”‚         â”‚     â”‚              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
                    â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
                    â”‚ JSON Filesâ”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Core Components

### 1. Import/Export Adapter System

DATEYE implements separate adapter interfaces for medical device integration:

```dart
// Import from medical devices
abstract class ImportAdapter {
  String get id;
  Future<bool> isParsable(String filePath);
  Future<ImportedDataFileModel> parse(String filePath);
}

// Export to medical devices/systems
abstract class IExportAdapter {
  String get id;
  String get displayName;
  String? get iconName;

  Future<Either<Failure, bool>> testConnection(ExportTarget target);
  Future<Either<Failure, ExportResult>> export({
    required ExportableDataFile data,
    required ExportTarget target,
  });
}
```

**Design Benefits:**
- **Clear Separation**: Import = data source, Export = data target
- **Type Safety**: Strongly typed interfaces with Either pattern
- **Testability**: Easy mocking and isolated testing
- **Extensibility**: Simple addition of new devices

### 2. File Storage Architecture

Data stored as NDJSON (Newline Delimited JSON) in the application directory:

```
DATEYE/
â”œâ”€â”€ events.ndjson              # Complete event history
â”œâ”€â”€ importingDevice.ndjson     # Import device configurations
â”œâ”€â”€ exportDestination.ndjson   # Export target configurations
â”œâ”€â”€ appConfigs.ndjson          # Application settings
â”œâ”€â”€ import/                    # Manual import directory
â”œâ”€â”€ export/                    # Temporary export storage
â”œâ”€â”€ archive/                   # Rotated logs
â””â”€â”€ secure/                    # Encrypted patient data
    â”œâ”€â”€ identity.key           # Master encryption key
    â””â”€â”€ patients.enc           # Encrypted patient identities
```

**Performance optimization**: Files use reverse chronological order - newest entries appear first for faster access.

**Default installation paths:**
- Windows: `C:\Users\%USERNAME%\AppData\Local\DATEYE`
- macOS: `~/Library/Application Support/DATEYE`
- Linux: `~/.config/DATEYE`

### 3. Data Flow Pipeline

**Import Flow:**
```
File Detection â†’ ImportAdapter â†’ Parse â†’ DATEYE Storage â†’ UI Update
```

**Export Flow:**
```
Export Request â†’ ExportAdapter â†’ Device/Target â†’ Result Logging
```

**Combined Workflow:**
```
Source Device â†’ ImportAdapter â†’ DATEYE â†’ ExportAdapter â†’ Target Device
```

## Data Models

Type-safe data models using Freezed for compile-time safety:

```dart
// Import data structure
@freezed
class ImportedDataFileModel with _$ImportedDataFileModel {
  const factory ImportedDataFileModel({
    required XmlDataPolarExportation xmlDataPolarExportation,
  }) = _ImportedDataFileModel;
}

// Export data structure
@freezed
class ExportableDataFile with _$ExportableDataFile {
  const factory ExportableDataFile({
    required DataFile file,
    required ExportDestination destination,
    @Default(0) double progress,
  }) = _ExportableDataFile;
}
```

**Benefits:**
- Compile-time error checking
- Immutable medical records
- Automatic JSON serialization
- Self-documenting interfaces

## Adapter Implementations

### Import Adapters

**Current Implementation:**

| Adapter | Status | Data Types |
|---------|---------|------------|
| **Topcon MYAH** | âœ… Complete | Axial length, keratometry, pupil data |
| **ZEISS IOLMaster** | ğŸ“‹ Planned | Optical biometry, IOL calculations |
| **Eye-Office** | ğŸ“‹ Planned | Demographics, refraction data |

**Example Implementation:**
```dart
@Named('topcon_myah')
@Singleton(as: ImportAdapter)
class TopconMyahImportAdapter implements ImportAdapter {
  const TopconMyahImportAdapter(this._parser);

  final IXmlParser _parser;

  @override
  String get id => 'topcon_myah';

  @override
  Future<ImportedDataFileModel> parse(String filePath) async {
    final xmlString = await getXmlStringFromFilePath(filePath);
    final jsonData = await _parser.parse(xmlString);
    return ImportedDataFileModel.fromJson(jsonData);
  }
}
```

### Export Adapters

**Current Implementation:**

| Adapter | Status | Capabilities |
|---------|---------|--------------|
| **Mediworks AL550** | âœ… Complete | Patient registration via HTTP API |
| **File Export** | ğŸ“‹ Planned | JSON/CSV file output |
| **Myopia.cloud** | ğŸ“‹ Planned | Cloud analytics upload |

**Example Implementation:**
```dart
@Named('al550_export')
@Singleton(as: IExportAdapter)
class AL550ExportAdapter implements IExportAdapter {
  const AL550ExportAdapter(this._httpClient);

  @override
  String get id => 'al550_export';

  @override
  Future<Either<Failure, ExportResult>> export({
    required ExportableDataFile data,
    required ExportTarget target,
  }) async {
    // Convert data to AL550 format
    final al550Patient = _formatPatientForAL550(data);

    // Send via HTTP API
    final response = await _httpClient.post(
      'http://${target.config['host']}:${target.config['port']}/setPatients',
      data: FormData.fromMap({'file': al550Patient}),
    );

    return response.statusCode == 200
        ? const Right(ExportResult.success())
        : Left(NetworkFailure('Export failed'));
  }
}
```

## Dependency Injection

GetIt + Injectable provide automatic adapter management:

```dart
// Self-registering adapters
@Named('topcon_myah')
@Singleton(as: ImportAdapter)
class TopconMyahImportAdapter implements ImportAdapter { ... }

@Named('al550_export')
@Singleton(as: IExportAdapter)
class AL550ExportAdapter implements IExportAdapter { ... }

// Auto-registration
@module
abstract class AdapterModule {
  @singleton
  Map<String, ImportAdapter> get importAdapters => {
    'topcon_myah': getIt<ImportAdapter>(instanceName: 'topcon_myah'),
  };

  @singleton
  Map<String, IExportAdapter> get exportAdapters => {
    'al550_export': getIt<IExportAdapter>(instanceName: 'al550_export'),
  };
}
```

**Benefits:**
- Testability through dependency injection
- Modular architecture
- Automatic dependency resolution
- Named adapter implementations

## State Management

BLoC pattern provides reactive UI updates:

```dart
// File system changes trigger UI updates
File Change â†’ File Watcher â†’ Cubit â†’ State â†’ UI

// Import/Export state management
class ImporterListenerCubit extends Cubit<ImporterListenerState> {
  void startWatching() {
    _database.watchAll<ImportingDevice>().listen((devices) {
      emit(state.copyWith(devices: devices));
    });
  }
}
```

**Two-Layer State Architecture:**
- **Persistent State**: NDJSON files as single source of truth
- **UI State**: In-memory state via BLoC for reactive updates

## Clean Architecture Implementation

Three distinct layers with unidirectional dependencies:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Presentation (Flutter UI + BLoC)       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Infrastructure (Adapters + Storage)    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Core (Entities + Use Cases)            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Dependency Rule**: Dependencies point inward only
- Core: No external dependencies
- Infrastructure: Depends on Core
- Presentation: Depends on Infrastructure and Core

## UI Integration Strategy

The UI shows "Source â†’ Target" workflows while maintaining separate adapters internally:

```dart
// UI presents unified workflow
class ConnectionsCubit extends Cubit<ConnectionsState> {
  void createConnection({
    required String sourceAdapterId,
    required String targetAdapterId,
  }) {
    // Create ImportDevice for source
    final importDevice = ImportingDevice(adapterId: sourceAdapterId, ...);

    // Create ExportDestination for target
    final exportDestination = ExportDestination(adapterId: targetAdapterId, ...);

    // Link them logically but keep separate
    emit(state.copyWith(newConnection: ConnectionWorkflow(
      source: importDevice,
      target: exportDestination,
    )));
  }
}
```

**UI Benefits:**
- User sees intuitive "MYAH â†’ AL550" workflow
- Technical implementation remains clean and separated
- Easy testing of import and export functionality independently

## Error Handling Strategy

### Error Isolation
- Import failures don't affect export functionality
- Export failures preserve original data integrity
- File corruption skips affected entries only
- Connection failures trigger automatic retry

### Either Pattern Implementation
```dart
// Import error handling
Future<Either<Failure, ImportResult>> importFile(String path) async {
  try {
    final adapter = _getImportAdapter(deviceType);
    final result = await adapter.parse(path);
    return Right(ImportResult.success(result));
  } catch (e) {
    return Left(ImportFailure('Import failed: $e'));
  }
}

// Export error handling
Future<Either<Failure, ExportResult>> exportData(ExportableDataFile data) async {
  try {
    final adapter = _getExportAdapter(data.destination.adapterId);
    return await adapter.export(data: data, target: data.destination);
  } catch (e) {
    return Left(ExportFailure('Export failed: $e'));
  }
}
```

## File Format Specifications

### Import Device Configuration (importingDevice.ndjson)
```json
{"id":"device_001","adapterId":"topcon_myah","name":"MYAH Biometer","config":{"path":"/import/myah","watchFolder":true},"enabled":true,"created":"2024-01-15T10:30:00Z"}
```

### Export Destination Configuration (exportDestination.ndjson)
```json
{"id":"dest_001","adapterId":"al550_export","name":"AL550 Main","config":{"host":"192.168.1.100","port":8080},"enabled":true,"created":"2024-01-15T10:30:00Z"}
```

### Event History (events.ndjson)
```json
{"id":"event_001","timestamp":"2024-01-15T10:30:00Z","type":"import","adapterId":"topcon_myah","status":"success","patientCount":1}
{"id":"event_002","timestamp":"2024-01-15T10:31:00Z","type":"export","adapterId":"al550_export","status":"success","patientCount":1}
```

## Security Model

### Current State
**WARNING: Encryption not yet implemented** - Critical priority before production deployment.

### Security Configuration

#### Encryption Key Management
**Critical: The `identity.key` file must be backed up. Loss of this file results in permanent data loss.**

Backup procedure:
1. Navigate to `DATEYE/secure/identity.key`
2. Copy to secure external storage
3. Store in physically secure location (e.g., safe)
4. Document backup location
5. Test recovery procedure quarterly

#### File System Permissions
Windows configuration:
```powershell
# Via GUI: Right-click secure folder â†’ Properties â†’ Security
# Remove all user permissions except current user
```

Unix-based systems:
```bash
chmod 700 ~/Library/Application\ Support/DATEYE/secure
chmod 600 ~/Library/Application\ Support/DATEYE/secure/*
```

#### Cloud Synchronization Exclusion
Prevent automatic cloud synchronization of sensitive files:
- **OneDrive**: Settings â†’ Choose folders â†’ Exclude DATEYE/secure
- **iCloud**: Append `.nosync` to filenames
- **Dropbox**: Selective Sync â†’ Deselect DATEYE/secure
- **Google Drive**: Preferences â†’ Exclude folder

### Planned Security Implementation

**Protected data:**
- Patient identities encrypted at rest (AES-256)
- Measurements stored separately from identities
- No network requirements for core operations
- Full GDPR compliance

## Implementation Status vs. Architecture Vision

### âœ… Implemented and Tested
- **ImportAdapter Pattern**: Fully functional with Topcon MYAH reference
- **Clean Architecture**: Three-layer separation implemented
- **NDJSON Storage Schema**: File formats defined and documented
- **BLoC State Management**: Infrastructure created

### ğŸš§ Framework Ready (Needs Implementation)
- **Storage Operations**: Database abstraction exists but untested
- **File Watching**: Code exists but integration incomplete
- **Error Handling**: Either pattern defined but not consistently used

### âŒ Planned but Not Implemented
- **IExportAdapter Pattern**: Design complete, implementation needed
- **Export Service Integration**: Repository stubs only
- **End-to-End Pipeline**: No connection between import and export
- **Device Discovery**: Framework missing
- **Patient Data Encryption**: Planned for production

## Architecture Benefits (When Complete)

### Projected Advantages
- **Zero Administration**: No database maintenance required
- **Portability**: Complete installation in single directory
- **Transparency**: Direct file inspection possible
- **Reliability**: Append-only operations prevent corruption
- **Performance**: No network latency for core operations
- **Separation of Concerns**: Clear import/export boundaries

### Design Trade-offs
- Single user limitation (intentional)
- Linear file search (acceptable for <10k patients)
- Manual log rotation requirement
- No real-time synchronization between separate adapters

## Implementation Status

### Completed
- ImportAdapter interface and Topcon MYAH implementation
- IExportAdapter interface and AL550 implementation
- NDJSON storage system
- BLoC state management
- Clean architecture foundation

### Remaining Work
- Additional import adapters (ZEISS, Eye-Office)
- File export adapter
- Patient data encryption
- UI workflow integration

## Extensibility

Architecture supports future enhancements without breaking changes:
- Additional import adapters for new devices
- Additional export adapters for cloud services
- Caching layer implementation
- Multi-user support via file locking
- Optional network synchronization

Extensions implemented only when requirements justify complexity (YAGNI principle).

## Related Documentation

- [Adapter Development](adapter-development.md) - Creating import/export adapters
- [Data Formats](data-formats.md) - JSON schema specifications
- [Deployment](deployment.md) - Installation and configuration
- [Flutter Implementation](flutter-implementation.md) - UI implementation



FILE: executive-summary.md
==================================================

# DATEYE Executive Summary

## Problem Statement

Medical practices lose significant productivity to manual data entry between incompatible medical devices. Current systems require clinical staff to manually transcribe measurement data between practice management software and diagnostic equipment, consuming approximately 30% of their time.

## Solution Overview

DATEYE provides automated data integration between medical devices through a desktop application that operates entirely offline. The system establishes secure data pathways between incompatible medical equipment without requiring internet connectivity or external dependencies.

### Key Capabilities

- **Automated Import**: Continuous monitoring and processing of data from multiple device types
- **Secure Export**: Encrypted transfer to target devices with automatic retry mechanisms
- **Offline Operation**: Zero internet requirements for core functionality
- **Audit Compliance**: Complete transaction logging for medical record requirements
- **Device Agnostic**: Supports major manufacturers through adapter architecture

## Business Impact

### Efficiency Gains
- **30% Time Reduction**: Eliminates manual data transcription
- **Error Prevention**: Automated transfer reduces human error risk
- **Staff Productivity**: Redirects clinical time to patient care
- **Workflow Optimization**: Seamless integration with existing practice patterns

### Risk Mitigation
- **Data Security**: AES-256 encryption for patient information
- **Compliance**: GDPR-compliant audit trails and data handling
- **Reliability**: Offline-first architecture eliminates network dependencies
- **Vendor Independence**: Open architecture prevents vendor lock-in

## Technical Architecture

### Design Principles
- **Privacy by Design**: Patient data encrypted locally, never transmitted unencrypted
- **Offline-First**: Core operation independent of internet connectivity
- **Simplicity**: Single desktop application, no server infrastructure required
- **Transparency**: Complete audit trail for all data operations

### System Requirements

#### Minimum Requirements
- Windows 10 / macOS 10.15 / Ubuntu 20.04
- 4GB RAM
- 100MB disk space (plus data storage)
- No internet connection required

#### Recommended Configuration
- 8GB RAM for practices with >1000 patients
- SSD storage for optimal performance
- Dedicated workstation in clinical environments

### Implementation Status
Current development progress: **70% complete**
- Core architecture implemented
- Import pipeline functional for primary devices
- Export framework requires completion
- Security encryption pending implementation

## Market Position

### Competitive Advantage
- **Unique Offline Architecture**: No cloud dependencies address security concerns
- **Universal Compatibility**: Adapter system supports diverse device ecosystem
- **Zero Infrastructure Cost**: No servers or ongoing service fees
- **Immediate Deployment**: Single installation, no configuration complexity

### Target Market
- Primary: Independent eye care practices (1-5 doctors)
- Secondary: Small medical device distributors seeking integration solutions
- Tertiary: Medical software companies requiring device connectivity

## Implementation Timeline

### Phase 1: Core Completion (4-6 weeks)
- Export functionality implementation
- Patient data encryption activation
- Additional device adapter development
- Comprehensive testing and validation

### Phase 2: Market Entry (8-12 weeks)
- Beta deployment in pilot practices
- Documentation finalization
- Training material development
- Production deployment preparation

## Investment Requirements

### Development Completion
- **Technical Implementation**: 4-6 weeks full-time development
- **Quality Assurance**: Comprehensive testing across device types
- **Documentation**: User guides and technical documentation
- **Compliance Validation**: Medical data handling verification

### Market Entry
- **Pilot Program**: 3-5 practice beta deployment
- **Marketing Materials**: Professional medical software presentation
- **Support Infrastructure**: Documentation and training resources
- **Distribution Strategy**: Direct sales and partner channel development

## Success Metrics

### Technical Metrics
- Startup time < 3 seconds
- Memory usage < 200MB
- Import processing < 1 second per file
- 99.9% data integrity accuracy

### Business Metrics
- 30% reduction in data entry time
- <5% user error rate
- 15-minute training requirement
- 95% user satisfaction rating

## Risk Assessment

### Technical Risks
- **Device Compatibility**: Mitigation through comprehensive adapter testing
- **Performance Scaling**: Architecture designed for practice-size deployments
- **Security Compliance**: Regular security audits and compliance validation

### Business Risks
- **Market Adoption**: Pilot program validates value proposition
- **Competition**: Technical differentiation through offline-first architecture
- **Regulatory Changes**: Modular design enables rapid compliance adaptation

## Conclusion

DATEYE addresses a critical inefficiency in medical practice operations through innovative offline-first architecture. The solution delivers immediate productivity gains while maintaining the highest security standards required for medical data handling.

The combination of proven technical architecture, clear market need, and minimal infrastructure requirements positions DATEYE for successful market entry and sustainable growth in the medical device integration sector.



FILE: data-formats.md
==================================================

# DATEYE Data Formats

Comprehensive specification of all data structures, file formats, and JSON schemas used in DATEYE's ImportAdapter/ExportAdapter architecture.

## Overview

DATEYE uses NDJSON (Newline Delimited JSON) for all data storage:
- **NDJSON Format**: One JSON object per line, reverse chronological order
- **Performance Optimization**: Recent entries at file beginning for fast access
- **Character Encoding**: UTF-8 exclusively

## File Storage Implementation

### Performance Optimization

Reverse-chronological storage pattern:
- New entries prepended to file beginning
- Enables fast access to recent data without full file reads
- Optimized for typical UI access patterns (recent data first)
- File watchers provide real-time update notifications

### Database Abstraction Layer

Database abstraction over NDJSON files:
```dart
// Abstraction hierarchy
IDatabase â†’ JsonFileStorageDatabase â†’ .ndjson files
```

Abstraction benefits:
- Pagination support (limit/skip operations)
- File watching for reactive updates
- Consistent error handling across operations
- Future storage backend flexibility

## Core File Specifications

### events.ndjson

Immutable operation history containing all system operations:

```json
{"id":"import_20240115_001","timestamp":"2024-01-15T10:30:00Z","type":"import","mode":"automatic","status":"success","adapter":"topcon_myah","secret_pid":"pat_001","measurements":{"axial_length":[{"eye":"right","value":24.52}]}}
{"id":"export_20240115_002","timestamp":"2024-01-15T10:31:00Z","type":"export","mode":"automatic","status":"success","adapter":"mediworks_al550","secret_pid":"pat_001","target":"al550_device"}
{"id":"import_20240115_003","timestamp":"2024-01-15T10:32:00Z","type":"import","mode":"manual","status":"success","adapter":"eye_office","file_count":2}
```

**Event Types:**
- `import` - Data imported from device/source into DATEYE
- `export` - Data exported from DATEYE to device/target
- `discovery` - Endpoint discovery operations
- `connection` - Connection lifecycle events (create, edit, delete)
- `system` - System events (startup, rotation)

**Common Field Definitions:**
```typescript
{
  id: string;          // Unique event identifier
  timestamp: string;   // ISO 8601 UTC timestamp
  type: string;        // Event category
  mode?: "automatic" | "manual" | "scheduled"; // Operation trigger method
  status: "success" | "error" | "pending" | "info";
  source?: string;     // Source endpoint identifier
  target?: string;     // Target endpoint identifier
  error?: string;      // Human-readable error message
  error_code?: string; // Machine-readable error identifier
}
```

### importingDevice.ndjson

Import source configurations:

```json
{"id":"import_001","adapterId":"topcon_myah","name":"MYAH Biometer","config":{"path":"/import/myah","watchFolder":true},"enabled":true,"created":"2024-01-15T10:30:00Z","lastImport":"2024-01-15T14:25:00Z"}
{"id":"import_002","adapterId":"eye_office","name":"Eye-Office API","config":{"url":"https://eye-office.local:4450","syncInterval":300,"apiKey":"encrypted:..."},"enabled":true,"created":"2024-01-15T10:35:00Z"}
```

### exportDestination.ndjson

Export target configurations:

```json
{"id":"export_001","adapterId":"mediworks_al550","name":"AL550 Main Device","config":{"host":"192.168.1.100","port":8080},"enabled":true,"created":"2024-01-15T10:30:00Z","lastExport":"2024-01-15T14:25:00Z"}
{"id":"export_002","adapterId":"file_export","name":"Daily Backup","config":{"path":"/backup/dateye","format":"json"},"enabled":true,"created":"2024-01-15T11:00:00Z"}
```

### appConfigs.ndjson

Application configuration structure:

```json
{
  "language": "de",
  "import": {
    "autoDiscovery": true,
    "discoveryTimeout": 5000,
    "defaultWatchInterval": 5000,
    "retryPolicy": {
      "maxRetries": 10,
      "backoffMultiplier": 2,
      "initialDelayMs": 1000
    }
  },
  "export": {
    "autoRetry": true,
    "defaultTimeout": 10000,
    "batchSize": 10
  },
  "adapters": {
    "registeredAdapters": [
      {
        "id": "topcon_myah",
        "name": "Topcon MYAH",
        "type": "import",
        "defaultConfig": {
          "timeout": 5000,
          "encoding": "utf-16"
        }
      },
      {
        "id": "mediworks_al550",
        "name": "Mediworks AL550",
        "type": "export",
        "defaultConfig": {
          "port": 8080,
          "timeout": 10000
        }
      }
    ]
  }
}

## Data Model Architecture

### Type Safety with Freezed

DATEYE implements compile-time type safety using Freezed:

- **Type Safety**: Compile-time error detection
- **Immutability**: Prevents accidental data modification
- **JSON Serialization**: Automatic bidirectional conversion
- **Union Types**: Flexible handling of variant data types

### Core Model Definitions

#### TransferData

Primary data structure for Sourceâ†’Target operations:

```dart
@freezed
class TransferData with _$TransferData {
  const factory TransferData({
    required String sourceEndpoint,
    required String targetEndpoint,
    required String secretPid,
    required Map<String, dynamic> patientData,
    required List<Measurement> measurements,
    required DateTime transferTime,
    String? connectionId,
    Map<String, dynamic>? metadata,
  }) = _TransferData;
}
```

#### Connection

Workflow configuration model:

```dart
@freezed
class Connection with _$Connection {
  const factory Connection({
    required String id,
    required String name,
    required String sourceEndpoint,
    required String targetEndpoint,
    required Map<String, dynamic> sourceConfig,
    required Map<String, dynamic> targetConfig,
    @Default(true) bool enabled,
    @Default('continuous') String mode,
    String? schedule,
    required DateTime created,
    DateTime? lastTransfer,
    @Default(0) int transferCount,
    @Default(0) int errorCount,
  }) = _Connection;
}
```

#### Measurement Models

```dart
// Axial Length measurement
@freezed
class AxialLength with _$AxialLength {
  const factory AxialLength({
    required String eye,  // 'right' or 'left'
    required double value, // millimeters
    double? snr,          // Signal-to-noise ratio
  }) = _AxialLength;
}

// Refraction measurement
@freezed
class ExamRefraction with _$ExamRefraction {
  const factory ExamRefraction({
    required String eye,
    required double sphere,
    required double cylinder,
    required int axis,
    double? addition,  // bifocal addition
  }) = _ExamRefraction;
}

// Complete examination
@freezed
class Examination with _$Examination {
  const factory Examination({
    required List<ExamRefraction> refractions,
    required List<AxialLength> axialLength,
    // Additional measurement types as needed
  }) = _Examination;
}
```

### Extensible Union Types

Future-proof measurement handling:

```dart
@freezed
class MeasurementData with _$MeasurementData {
  // Strongly-typed known measurements
  const factory MeasurementData.axialLength({
    required String eye,
    required double value,
    double? snr,
  }) = AxialLengthData;

  const factory MeasurementData.refraction({
    required String eye,
    required double sphere,
    required double cylinder,
    required int axis,
  }) = RefractionData;

  // Generic fallback for unknown types
  const factory MeasurementData.custom(
    String type,
    Map<String, dynamic> data,
  ) = CustomData;
}
```

Benefits:
- Type-safe handling of known measurements
- Extensibility for future measurement types
- Gradual migration path for new data types

## Transfer History Structure

Standard transfer record format:

```json
{
  "id": "transfer_001",
  "timestamp": "2024-01-15T10:30:00Z",
  "type": "transfer",
  "source": "topcon_myah",
  "target": "mediworks_al550",
  "connection_id": "conn_001",
  "secret_pid": "pat_001",
  "measurements": [
    {
      "type": "axial_length",
      "data": {
        "eye": "right",
        "value": 24.52,
        "snr": 12.5,
        "measured_at": "2024-01-15T10:25:00Z"
      }
    }
  ],
  "metadata": {
    "source_file": "patient_001.xml",
    "processing_time_ms": 1250,
    "data_quality": "high"
  }
}
```

### Measurement Type Specifications

**Refraction (Optical prescription):**
```json
{
  "type": "refraction",
  "data": {
    "eye": "right",
    "sphere": -2.25,
    "cylinder": -0.50,
    "axis": 90,
    "addition": 2.00,  // Optional
    "vertex": 12       // Optional
  }
}
```

**Biometry (Ocular measurements):**
```json
{
  "type": "biometry",
  "data": {
    "eye": "right",
    "axial_length": 24.52,
    "acd": 3.21,              // Anterior chamber depth
    "lens_thickness": 3.65,   // Optional
    "white_to_white": 11.8    // Optional
  }
}
```

**Keratometry (Corneal measurements):**
```json
{
  "type": "cornea",
  "data": {
    "eye": "right",
    "k1_d": 43.11,     // Flat meridian (diopters)
    "k1_mm": 7.83,     // Flat meridian (mm radius)
    "k2_d": 44.36,     // Steep meridian (diopters)
    "k2_mm": 7.61,     // Steep meridian (mm radius)
    "axis_k1": 180,
    "axis_k2": 90,
    "astigmatism": 1.25
  }
}
```

## Endpoint-to-DATEYE Mappings

### Topcon MYAH Conversion
```xml
<!-- Device XML Format -->
<FlatK>7.89</FlatK>
<SteepK>7.72</SteepK>
<AxialLength>24.52</AxialLength>
```

```dart
// DATEYE Internal Format
AxialLength(eye: 'right', value: 24.52)
// Keratometry: k1_d = 337.5 / 7.89 = 42.77 D
```

### Eye-Office Conversion
```json
// Device JSON Format
{
  "refrRight": {
    "sphere": -2.25,
    "cylinder": -0.50,
    "axisCylinder": 90
  }
}
```

```dart
// DATEYE Internal Format
ExamRefraction(
  eye: 'right',
  sphere: -2.25,
  cylinder: -0.50,
  axis: 90
)
```

### Measurement Validation Rules

| Measurement | Field | Normal Range | Unit | Notes |
|-------------|-------|-------------|------|-------|
| Refraction | sphere | -20 to +20 | diopters | Negative for myopia |
| Refraction | cylinder | -10 to 0 | diopters | Always negative convention |
| Refraction | axis | 0 to 180 | degrees | TABO notation |
| AxialLength | value | 20 to 30 | mm | Typical: 22-26mm |
| AxialLength | snr | >5.0 | - | Quality metric |
| Keratometry | k1_d, k2_d | 38 to 50 | diopters | Calculated from radius |
| Visual Acuity | value | 0.1 to 2.0 | decimal | 1.0 = 20/20 |
| Pupil | diameter | 1.5 to 9.0 | mm | Light-dependent |

## Identifier Generation

### Event IDs
Pattern: `{type}_{YYYYMMDD}_{NNN}`
- `transfer_20240115_042`
- `sync_20240115_043`
- `discovery_20240115_044`

### Connection IDs
Pattern: `conn_{NNN}`
- `conn_001`, `conn_002`, etc.
- Sequential numbering for simplicity

### Patient IDs
Pattern: `pat_YYYYMMDD_NNN`
- Timestamp-based generation
- Collision-free design
- Human-readable format

## File Maintenance

### Daily Log Rotation
Executed at midnight local time:
1. Rename `history.ndjson` to `archive/history-YYYY-MM-DD.json`
2. Create new empty `history.ndjson`
3. Log rotation event

### Monthly Archive Process
First day of each month:
1. Archive completed transfers
2. Retain only active connections
3. Clean expired discovery data

## Error Code Standards

Format: `CATEGORY_SPECIFIC_ERROR`

Categories:
- `ENDPOINT_` - Endpoint communication errors
- `TRANSFER_` - Data transfer failures
- `CONNECTION_` - Connection configuration issues
- `VALIDATION_` - Data validation failures
- `DISCOVERY_` - Endpoint discovery problems
- `SYSTEM_` - System-level errors

Examples:
- `ENDPOINT_TIMEOUT`
- `TRANSFER_DATA_INVALID`
- `CONNECTION_CONFIG_MISSING`
- `VALIDATION_OUT_OF_RANGE`
- `DISCOVERY_NO_DEVICES_FOUND`

## Implementation Guidelines

1. **JSON Validation**: Validate before writing
2. **Atomic Operations**: Use transactions for multi-file updates
3. **Partial Read Handling**: Support incomplete JSON Lines reads
4. **Timestamp Standards**: UTC with timezone information
5. **Forward Compatibility**: Preserve unrecognized fields

## Related Documentation

- [Architecture](architecture.md) - System design overview
- [Endpoint Development](adapter-development.md) - Data format usage


FILE: adapter-development.md
==================================================

# Import/Export Adapter Development

Guide for implementing ImportAdapter and IExportAdapter interfaces to integrate medical devices with DATEYE.

## Overview

DATEYE uses separate adapter interfaces for medical device integration:
- **ImportAdapter**: Import data from medical devices into DATEYE
- **IExportAdapter**: Export data from DATEYE to medical devices/systems

This separation provides clear boundaries, easier testing, and logical organization.

## ImportAdapter Interface

```dart
abstract class ImportAdapter {
  /// Unique adapter identifier
  String get id;

  /// Check if the adapter can parse the given file
  Future<bool> isParsable(String filePath);

  /// Parse into internal format
  Future<ImportedDataFileModel> parse(String filePath);
}
```

### Implementation Pattern

```dart
@Named('your_device')
@Singleton(as: ImportAdapter)
class YourDeviceImportAdapter implements ImportAdapter {
  const YourDeviceImportAdapter(this._dependencies);

  @override
  String get id => 'your_device';

  @override
  Future<bool> isParsable(String filePath) async {
    // Check file format, extension, content
    try {
      final content = await File(filePath).readAsString();
      return content.contains('YOUR_DEVICE_SIGNATURE');
    } catch (e) {
      return false;
    }
  }

  @override
  Future<ImportedDataFileModel> parse(String filePath) async {
    // Parse device-specific format to internal format
    final content = await File(filePath).readAsString();
    final parsed = _parseDeviceFormat(content);
    return ImportedDataFileModel.fromDeviceData(parsed);
  }
}
```

## IExportAdapter Interface

**STATUS**: âŒ NOT YET IMPLEMENTED - Implementation needed

**File**: `lib/infrastructure/adapters/i_export_adapter.dart`

```dart
// NEEDS IMPLEMENTATION - This interface does not exist yet
abstract class IExportAdapter {
  /// Unique identifier for this adapter
  String get id;

  /// Human-readable display name
  String get displayName;

  /// Icon name for UI display (optional)
  String? get iconName => null;

  /// Test if this adapter can connect to the given target
  Future<Either<Failure, bool>> testConnection(ExportDestination target);

  /// Export data to the specified target
  Future<Either<Failure, ExportResult>> export({
    required ExportableDataFile data,
    required ExportDestination target,
  });

  /// Get configuration schema for this adapter
  Map<String, dynamic> get configSchema => {};

  /// Validate configuration for this adapter
  Either<Failure, Unit> validateConfig(Map<String, dynamic> config) {
    return const Right(unit);
  }
}
```

**Implementation Priority**: HIGH - Needed for any export functionality
```

### Implementation Pattern

```dart
@Named('your_export_device')
@Singleton(as: IExportAdapter)
class YourExportAdapter implements IExportAdapter {
  const YourExportAdapter(this._httpClient);

  final IHttpClient _httpClient;

  @override
  String get id => 'your_export_device';

  @override
  String get displayName => 'Your Export Device';

  @override
  String? get iconName => 'device_icon';

  @override
  Map<String, dynamic> get configSchema => {
    'type': 'object',
    'required': ['host', 'port'],
    'properties': {
      'host': {
        'type': 'string',
        'title': 'Device IP Address',
        'pattern': r'^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$',
      },
      'port': {
        'type': 'integer',
        'title': 'Port',
        'default': 8080,
        'minimum': 1,
        'maximum': 65535,
      },
    },
  };

  @override
  Either<Failure, Unit> validateConfig(Map<String, dynamic> config) {
    final host = config['host'] as String?;
    final port = config['port'] as int?;

    if (host == null || host.isEmpty) {
      return Left(ValidationFailure('Host is required'));
    }

    if (port == null || port <= 0 || port > 65535) {
      return Left(ValidationFailure('Valid port required'));
    }

    return const Right(unit);
  }

  @override
  Future<Either<Failure, bool>> testConnection(ExportTarget target) async {
    try {
      final host = target.config['host'] as String;
      final port = target.config['port'] as int;

      final response = await _httpClient.get(
        'http://$host:$port/status',
        options: HttpRequestOptions(connectTimeout: Duration(seconds: 5)),
      );

      return Right(response.statusCode == 200);
    } catch (e) {
      return Left(NetworkFailure('Connection test failed: $e'));
    }
  }

  @override
  Future<Either<Failure, ExportResult>> export({
    required ExportableDataFile data,
    required ExportTarget target,
  }) async {
    try {
      // Validate configuration
      final validation = validateConfig(target.config);
      if (validation.isLeft()) return Left(validation.getLeft().toNullable()!);

      // Convert data to device format
      final deviceData = _convertToDeviceFormat(data);

      // Send to device
      final response = await _httpClient.post(
        'http://${target.config['host']}:${target.config['port']}/import',
        data: deviceData,
      );

      if (response.statusCode == 200) {
        return const Right(ExportResult.success(
          message: 'Data exported successfully',
        ));
      } else {
        return Left(NetworkFailure('Export failed: ${response.statusCode}'));
      }
    } catch (e) {
      return Left(ExportFailure('Export error: $e'));
    }
  }

  Map<String, dynamic> _convertToDeviceFormat(ExportableDataFile data) {
    // Convert DATEYE format to device-specific format
    return {
      'patients': [], // Extract from data
      'timestamp': DateTime.now().toIso8601String(),
    };
  }
}
```

## Data Models

### ImportedDataFileModel

The internal data structure for imported data:

```dart
@freezed
class ImportedDataFileModel with _$ImportedDataFileModel {
  const factory ImportedDataFileModel({
    required XmlDataPolarExportation xmlDataPolarExportation,
  }) = _ImportedDataFileModel;

  factory ImportedDataFileModel.fromJson(Map<String, dynamic> json) =>
      _$ImportedDataFileModelFromJson(json);
}
```

### ExportableDataFile

The data structure for export operations:

```dart
@freezed
class ExportableDataFile with _$ExportableDataFile {
  const factory ExportableDataFile({
    required DataFile file,
    required ExportDestination destination,
    @Default(0) double progress,
  }) = _ExportableDataFile;
}
```

### ExportTarget and ExportResult

```dart
class ExportTarget {
  const ExportTarget({
    required this.id,
    required this.name,
    required this.adapterId,
    required this.config,
    this.enabled = true,
  });

  final String id;
  final String name;
  final String adapterId;
  final Map<String, dynamic> config;
  final bool enabled;
}

// Result types
abstract class ExportResult {
  const factory ExportResult.success({
    String? message,
    Map<String, dynamic>? metadata,
  }) = ExportSuccess;

  const factory ExportResult.failure({
    required String error,
    String? errorCode,
    bool retryable = true,
  }) = ExportFailure;
}
```

## Example Implementations

### Topcon MYAH Import Adapter

```dart
@Named('topcon_myah')
@Singleton(as: ImportAdapter)
class TopconMyahImportAdapter implements ImportAdapter {
  const TopconMyahImportAdapter(this._parser);

  final IXmlParser _parser;

  @override
  String get id => 'topcon_myah';

  @override
  Future<bool> isParsable(String filePath) async {
    try {
      final xmlString = await getXmlStringFromFilePath(filePath);
      return _parser.isParsable(xmlString);
    } catch (e) {
      return false;
    }
  }

  @override
  Future<ImportedDataFileModel> parse(String filePath) async {
    // Read UTF-16 encoded XML file
    final xmlBytes = await File(filePath).readAsBytes();
    final utf16CodeUnits = xmlBytes.buffer.asUint16List();
    final xmlString = String.fromCharCodes(utf16CodeUnits);

    // Parse XML to JSON
    final jsonData = await _parser.parse(xmlString);

    // Handle single PatientEyeData conversion to list
    if (jsonData['XMLDataPolarExportation']?['PatientEyeData'] is Map) {
      jsonData['XMLDataPolarExportation']['PatientEyeData'] =
          [jsonData['XMLDataPolarExportation']['PatientEyeData']];
    }

    return ImportedDataFileModel.fromJson(jsonData);
  }

  Future<String> getXmlStringFromFilePath(String filePath) async {
    final xmlBytes = await File(filePath).readAsBytes();
    final utf16CodeUnits = xmlBytes.buffer.asUint16List();
    return String.fromCharCodes(utf16CodeUnits);
  }
}
```

### Mediworks AL550 Export Adapter

**STATUS**: âŒ NOT YET IMPLEMENTED - High priority reference implementation

**File**: `lib/infrastructure/adapters/al550_export_adapter.dart`

```dart
// NEEDS IMPLEMENTATION - This adapter does not exist yet
@Named('al550_export')
@Singleton(as: IExportAdapter)
class AL550ExportAdapter implements IExportAdapter {
  const AL550ExportAdapter(this._httpClient);

  final IHttpClient _httpClient;

  @override
  String get id => 'al550_export';

  @override
  String get displayName => 'Mediworks AL550';

  @override
  Map<String, dynamic> get configSchema => {
    'type': 'object',
    'required': ['host', 'port'],
    'properties': {
      'host': {
        'type': 'string',
        'title': 'Device IP Address',
        'pattern': r'^(?:[0-9]{1,3}\.){3}[0-9]{1,3}

## Adapter Registration

```dart
// Automatic registration via Injectable
@module
abstract class AdapterModule {
  @singleton
  Map<String, ImportAdapter> get importAdapters {
    final getIt = GetIt.instance;
    return {
      'topcon_myah': getIt<ImportAdapter>(instanceName: 'topcon_myah'),
      // Add more import adapters here
    };
  }

  @singleton
  Map<String, IExportAdapter> get exportAdapters {
    final getIt = GetIt.instance;
    return {
      'al550_export': getIt<IExportAdapter>(instanceName: 'al550_export'),
      // Add more export adapters here
    };
  }
}
```

## Error Handling

### Import Error Handling

```dart
Future<Either<Failure, ImportResult>> processImport(String filePath) async {
  try {
    final adapter = _getAdapterForFile(filePath);
    if (adapter == null) {
      return Left(ImportFailure('No suitable adapter found'));
    }

    if (!await adapter.isParsable(filePath)) {
      return Left(ImportFailure('File format not supported'));
    }

    final result = await adapter.parse(filePath);
    return Right(ImportResult.success(result));
  } on FileSystemException catch (e) {
    return Left(ImportFailure('File access error: $e'));
  } on FormatException catch (e) {
    return Left(ImportFailure('Invalid file format: $e'));
  } catch (e) {
    return Left(ImportFailure('Unexpected error: $e'));
  }
}
```

### Export Error Handling

```dart
Future<Either<Failure, ExportResult>> processExport(
  ExportableDataFile data,
  ExportTarget target,
) async {
  try {
    final adapter = _getExportAdapter(target.adapterId);
    if (adapter == null) {
      return Left(ExportFailure('Export adapter not found'));
    }

    // Test connection first
    final connectionTest = await adapter.testConnection(target);
    if (connectionTest.isLeft()) {
      return Left(connectionTest.getLeft().toNullable()!);
    }

    if (!connectionTest.getRight().toNullable()!) {
      return Left(NetworkFailure('Cannot connect to target device'));
    }

    // Perform export
    return await adapter.export(data: data, target: target);
  } catch (e) {
    return Left(ExportFailure('Export failed: $e'));
  }
}
```

## Testing Strategies

### Import Adapter Testing

```dart
void main() {
  group('TopconMyahImportAdapter', () {
    late TopconMyahImportAdapter adapter;
    late MockXmlParser mockParser;

    setUp(() {
      mockParser = MockXmlParser();
      adapter = TopconMyahImportAdapter(mockParser);
    });

    test('parses valid MYAH file', () async {
      // Arrange
      const filePath = 'test/data/valid_myah.xml';
      final expectedJson = {'XMLDataPolarExportation': {...}};

      when(mockParser.isParsable(any)).thenReturn(true);
      when(mockParser.parse(any)).thenAnswer((_) async => expectedJson);

      // Act
      final result = await adapter.parse(filePath);

      // Assert
      expect(result, isA<ImportedDataFileModel>());
      verify(mockParser.parse(any)).called(1);
    });

    test('rejects invalid file format', () async {
      // Arrange
      const filePath = 'test/data/invalid.txt';
      when(mockParser.isParsable(any)).thenReturn(false);

      // Act
      final canParse = await adapter.isParsable(filePath);

      // Assert
      expect(canParse, false);
    });
  });
}
```

### Export Adapter Testing

```dart
void main() {
  group('AL550ExportAdapter', () {
    late AL550ExportAdapter adapter;
    late MockHttpClient mockHttpClient;

    setUp(() {
      mockHttpClient = MockHttpClient();
      adapter = AL550ExportAdapter(mockHttpClient);
    });

    test('successfully exports patient data', () async {
      // Arrange
      final target = ExportTarget(
        id: 'test',
        name: 'Test AL550',
        adapterId: 'al550_export',
        config: {'host': '192.168.1.100', 'port': 8080},
      );

      final data = createTestExportData();

      when(mockHttpClient.get(any, options: anyNamed('options')))
          .thenAnswer((_) async => HttpResponse(statusCode: 200, data: []));
      when(mockHttpClient.post(any, data: anyNamed('data')))
          .thenAnswer((_) async => HttpResponse(statusCode: 200, data: 'ok'));

      // Act
      final result = await adapter.export(data: data, target: target);

      // Assert
      expect(result.isRight(), true);
      expect(result.getRight().toNullable()!.isSuccess, true);
    });

    test('handles connection failure', () async {
      // Arrange
      final target = createTestTarget();
      when(mockHttpClient.get(any, options: anyNamed('options')))
          .thenThrow(SocketException('Connection failed'));

      // Act
      final result = await adapter.testConnection(target);

      // Assert
      expect(result.isLeft(), true);
      expect(result.getLeft().toNullable(), isA<NetworkFailure>());
    });
  });
}
```

## Configuration Schema

For export adapters that need configuration:

```dart
@override
Map<String, dynamic> get configSchema => {
  'type': 'object',
  'required': ['host'],
  'properties': {
    'host': {
      'type': 'string',
      'title': 'Device IP Address',
      'description': 'IP address of the device',
      'pattern': r'^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$',
    },
    'port': {
      'type': 'integer',
      'title': 'Port Number',
      'default': 8080,
      'minimum': 1,
      'maximum': 65535,
    },
    'timeout': {
      'type': 'integer',
      'title': 'Timeout (seconds)',
      'default': 10,
      'minimum': 1,
      'maximum': 60,
    },
    'enableSSL': {
      'type': 'boolean',
      'title': 'Enable SSL',
      'default': false,
    },
  },
};
```

## Implementation Guidelines

### Best Practices

1. **Error Handling**: Always use Either pattern for error handling
2. **Validation**: Validate all input data and configurations
3. **Testing**: Write comprehensive unit tests for all adapters
4. **Documentation**: Document data format requirements and limitations
5. **Dependencies**: Inject all dependencies for testability

### Performance Considerations

1. **File Operations**: Use async file operations
2. **Network Requests**: Implement proper timeouts
3. **Memory Usage**: Stream large files instead of loading entirely
4. **Caching**: Cache parsed data when appropriate

### Security Requirements

1. **Input Validation**: Sanitize all external data
2. **Network Security**: Use HTTPS where possible
3. **Credential Storage**: Never log sensitive information
4. **Error Messages**: Don't expose internal system details

## Related Documentation

- [Architecture](architecture.md) - System design overview
- [Data Formats](data-formats.md) - JSON schema specifications
- [Testing Guide](testing.md) - Testing strategies and patterns
,
      },
      'port': {
        'type': 'integer',
        'title': 'Port',
        'default': 8080,
        'minimum': 1,
        'maximum': 65535,
      },
    },
  };

  @override
  Future<Either<Failure, bool>> testConnection(ExportDestination target) async {
    try {
      final host = target.config['host'] as String;
      final port = target.config['port'] as int;

      final response = await _httpClient.get(
        'http://$host:$port/getPatients',
        options: HttpRequestOptions(connectTimeout: Duration(seconds: 5)),
      );

      return Right(response.statusCode == 200);
    } catch (e) {
      return Left(NetworkFailure('AL550 connection failed: $e'));
    }
  }

  @override
  Future<Either<Failure, ExportResult>> export({
    required ExportableDataFile data,
    required ExportDestination target,
  }) async {
    // Implementation following Mediworks API documentation
    // See: docs/external-apis/mediworks/setPatients-en.md

    // TODO: Implement patient registration via HTTP POST
    // TODO: Handle existing patient detection
    // TODO: Format data according to AL550 API requirements
    throw UnimplementedError('AL550 export adapter needs implementation');
  }
}
```

**Implementation Notes**:
- Reference Mediworks API documentation in `/docs/external-apis/mediworks/`
- Use existing IHttpClient from infrastructure layer
- Follow exact same DI pattern as TopconMyahImportAdapter
- Test with actual AL550 device during development

## Adapter Registration

```dart
// Automatic registration via Injectable
@module
abstract class AdapterModule {
  @singleton
  Map<String, ImportAdapter> get importAdapters {
    final getIt = GetIt.instance;
    return {
      'topcon_myah': getIt<ImportAdapter>(instanceName: 'topcon_myah'),
      // Add more import adapters here
    };
  }

  @singleton
  Map<String, IExportAdapter> get exportAdapters {
    final getIt = GetIt.instance;
    return {
      'al550_export': getIt<IExportAdapter>(instanceName: 'al550_export'),
      // Add more export adapters here
    };
  }
}
```

## Error Handling

### Import Error Handling

```dart
Future<Either<Failure, ImportResult>> processImport(String filePath) async {
  try {
    final adapter = _getAdapterForFile(filePath);
    if (adapter == null) {
      return Left(ImportFailure('No suitable adapter found'));
    }

    if (!await adapter.isParsable(filePath)) {
      return Left(ImportFailure('File format not supported'));
    }

    final result = await adapter.parse(filePath);
    return Right(ImportResult.success(result));
  } on FileSystemException catch (e) {
    return Left(ImportFailure('File access error: $e'));
  } on FormatException catch (e) {
    return Left(ImportFailure('Invalid file format: $e'));
  } catch (e) {
    return Left(ImportFailure('Unexpected error: $e'));
  }
}
```

### Export Error Handling

```dart
Future<Either<Failure, ExportResult>> processExport(
  ExportableDataFile data,
  ExportTarget target,
) async {
  try {
    final adapter = _getExportAdapter(target.adapterId);
    if (adapter == null) {
      return Left(ExportFailure('Export adapter not found'));
    }

    // Test connection first
    final connectionTest = await adapter.testConnection(target);
    if (connectionTest.isLeft()) {
      return Left(connectionTest.getLeft().toNullable()!);
    }

    if (!connectionTest.getRight().toNullable()!) {
      return Left(NetworkFailure('Cannot connect to target device'));
    }

    // Perform export
    return await adapter.export(data: data, target: target);
  } catch (e) {
    return Left(ExportFailure('Export failed: $e'));
  }
}
```

## Testing Strategies

### Import Adapter Testing

```dart
void main() {
  group('TopconMyahImportAdapter', () {
    late TopconMyahImportAdapter adapter;
    late MockXmlParser mockParser;

    setUp(() {
      mockParser = MockXmlParser();
      adapter = TopconMyahImportAdapter(mockParser);
    });

    test('parses valid MYAH file', () async {
      // Arrange
      const filePath = 'test/data/valid_myah.xml';
      final expectedJson = {'XMLDataPolarExportation': {...}};

      when(mockParser.isParsable(any)).thenReturn(true);
      when(mockParser.parse(any)).thenAnswer((_) async => expectedJson);

      // Act
      final result = await adapter.parse(filePath);

      // Assert
      expect(result, isA<ImportedDataFileModel>());
      verify(mockParser.parse(any)).called(1);
    });

    test('rejects invalid file format', () async {
      // Arrange
      const filePath = 'test/data/invalid.txt';
      when(mockParser.isParsable(any)).thenReturn(false);

      // Act
      final canParse = await adapter.isParsable(filePath);

      // Assert
      expect(canParse, false);
    });
  });
}
```

### Export Adapter Testing

```dart
void main() {
  group('AL550ExportAdapter', () {
    late AL550ExportAdapter adapter;
    late MockHttpClient mockHttpClient;

    setUp(() {
      mockHttpClient = MockHttpClient();
      adapter = AL550ExportAdapter(mockHttpClient);
    });

    test('successfully exports patient data', () async {
      // Arrange
      final target = ExportTarget(
        id: 'test',
        name: 'Test AL550',
        adapterId: 'al550_export',
        config: {'host': '192.168.1.100', 'port': 8080},
      );

      final data = createTestExportData();

      when(mockHttpClient.get(any, options: anyNamed('options')))
          .thenAnswer((_) async => HttpResponse(statusCode: 200, data: []));
      when(mockHttpClient.post(any, data: anyNamed('data')))
          .thenAnswer((_) async => HttpResponse(statusCode: 200, data: 'ok'));

      // Act
      final result = await adapter.export(data: data, target: target);

      // Assert
      expect(result.isRight(), true);
      expect(result.getRight().toNullable()!.isSuccess, true);
    });

    test('handles connection failure', () async {
      // Arrange
      final target = createTestTarget();
      when(mockHttpClient.get(any, options: anyNamed('options')))
          .thenThrow(SocketException('Connection failed'));

      // Act
      final result = await adapter.testConnection(target);

      // Assert
      expect(result.isLeft(), true);
      expect(result.getLeft().toNullable(), isA<NetworkFailure>());
    });
  });
}
```

## Configuration Schema

For export adapters that need configuration:

```dart
@override
Map<String, dynamic> get configSchema => {
  'type': 'object',
  'required': ['host'],
  'properties': {
    'host': {
      'type': 'string',
      'title': 'Device IP Address',
      'description': 'IP address of the device',
      'pattern': r'^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$',
    },
    'port': {
      'type': 'integer',
      'title': 'Port Number',
      'default': 8080,
      'minimum': 1,
      'maximum': 65535,
    },
    'timeout': {
      'type': 'integer',
      'title': 'Timeout (seconds)',
      'default': 10,
      'minimum': 1,
      'maximum': 60,
    },
    'enableSSL': {
      'type': 'boolean',
      'title': 'Enable SSL',
      'default': false,
    },
  },
};
```

## Implementation Guidelines

### Best Practices

1. **Error Handling**: Always use Either pattern for error handling
2. **Validation**: Validate all input data and configurations
3. **Testing**: Write comprehensive unit tests for all adapters
4. **Documentation**: Document data format requirements and limitations
5. **Dependencies**: Inject all dependencies for testability

### Performance Considerations

1. **File Operations**: Use async file operations
2. **Network Requests**: Implement proper timeouts
3. **Memory Usage**: Stream large files instead of loading entirely
4. **Caching**: Cache parsed data when appropriate

### Security Requirements

1. **Input Validation**: Sanitize all external data
2. **Network Security**: Use HTTPS where possible
3. **Credential Storage**: Never log sensitive information
4. **Error Messages**: Don't expose internal system details

## Related Documentation

- [Architecture](architecture.md) - System design overview
- [Data Formats](data-formats.md) - JSON schema specifications
- [Testing Guide](testing.md) - Testing strategies and patterns



FILE: flutter-implementation.md
==================================================

# Flutter Implementation Guide

Platform-native desktop application development using Flutter framework.

## Platform-Native UI Strategy

DATEYE implements native UI components for each platform to ensure professional, familiar user experiences:
- **Windows**: Fluent UI (Microsoft design system)
- **macOS**: macOS UI (Apple design language)
- **Linux**: Yaru (Ubuntu/GNOME design)

Implementation priority: Windows â†’ macOS â†’ Linux

## Project Structure

```
lib/
â”œâ”€â”€ core/                    # Business logic (platform-independent)
â”‚   â”œâ”€â”€ models/             # Data models
â”‚   â”œâ”€â”€ services/           # Business services
â”‚   â””â”€â”€ repositories/       # Data repositories
â”‚
â”œâ”€â”€ infrastructure/          # Technical implementation
â”‚   â”œâ”€â”€ adapters/           # Device adapters
â”‚   â”‚   â”œâ”€â”€ import/
â”‚   â”‚   â””â”€â”€ export/
â”‚   â”œâ”€â”€ storage/            # File/data persistence
â”‚   â””â”€â”€ platform/           # Platform-specific services
â”‚
â”œâ”€â”€ presentation/            # UI layer (platform-specific)
â”‚   â”œâ”€â”€ windows/            # Windows UI (Fluent UI)
â”‚   â”‚   â”œâ”€â”€ app.dart
â”‚   â”‚   â”œâ”€â”€ screens/
â”‚   â”‚   â”œâ”€â”€ widgets/
â”‚   â”‚   â””â”€â”€ theme/
â”‚   â”œâ”€â”€ macos/              # macOS UI (macOS UI)
â”‚   â”‚   â”œâ”€â”€ app.dart
â”‚   â”‚   â”œâ”€â”€ screens/
â”‚   â”‚   â”œâ”€â”€ widgets/
â”‚   â”‚   â””â”€â”€ theme/
â”‚   â”œâ”€â”€ linux/              # Linux UI (Yaru)
â”‚   â”‚   â”œâ”€â”€ app.dart
â”‚   â”‚   â”œâ”€â”€ screens/
â”‚   â”‚   â”œâ”€â”€ widgets/
â”‚   â”‚   â””â”€â”€ theme/
â”‚   â””â”€â”€ shared/             # Shared UI logic
â”‚       â”œâ”€â”€ bloc/           # State management
â”‚       â”œâ”€â”€ routing/        # Navigation
â”‚       â””â”€â”€ l10n/           # Localization
â”‚
â””â”€â”€ main.dart               # Platform-aware entry point
```

## Platform-Aware Entry Point

```dart
// main.dart
import 'dart:io';
import 'package:fluent_ui/fluent_ui.dart' as fluent;
import 'package:macos_ui/macos_ui.dart';
import 'package:yaru/yaru.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // Initialize core services
  await initializeCore();

  // Launch platform-specific app
  if (Platform.isWindows) {
    runApp(WindowsDateyeApp());
  } else if (Platform.isMacOS) {
    runApp(MacOSDateyeApp());
  } else if (Platform.isLinux) {
    runApp(LinuxDateyeApp());
  }
}
```

## Windows Implementation (Priority 1)

### Dependencies
```yaml
dependencies:
  fluent_ui: ^4.7.0
  system_tray: ^2.0.0
  windows_taskbar: ^1.1.0
```

### App Structure
```dart
// presentation/windows/app.dart
import 'package:fluent_ui/fluent_ui.dart';

class WindowsDateyeApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return FluentApp(
      title: 'DATEYE',
      theme: FluentThemeData(
        accentColor: Colors.teal,
        visualDensity: VisualDensity.standard,
        fontFamily: 'Segoe UI',
      ),
      darkTheme: FluentThemeData(
        brightness: Brightness.dark,
        accentColor: Colors.teal,
      ),
      home: WindowsShell(),
      localizationsDelegates: [
        FluentLocalizations.delegate,
        ...AppLocalizations.localizationsDelegates,
      ],
    );
  }
}
```

### Navigation Shell
```dart
// presentation/windows/screens/shell.dart
class WindowsShell extends StatefulWidget {
  @override
  _WindowsShellState createState() => _WindowsShellState();
}

class _WindowsShellState extends State<WindowsShell> {
  int _index = 0;

  @override
  Widget build(BuildContext context) {
    return NavigationView(
      appBar: NavigationAppBar(
        automaticallyImplyLeading: false,
        title: const Text('DATEYE'),
        actions: Row(
          mainAxisAlignment: MainAxisAlignment.end,
          children: [
            IconButton(
              icon: const Icon(FluentIcons.settings),
              onPressed: () => _navigateToSettings(),
            ),
          ],
        ),
      ),
      pane: NavigationPane(
        selected: _index,
        onChanged: (i) => setState(() => _index = i),
        displayMode: PaneDisplayMode.top,
        items: [
          PaneItem(
            icon: const Icon(FluentIcons.home),
            title: const Text('Dashboard'),
            body: const DashboardScreen(),
          ),
          PaneItem(
            icon: const Icon(FluentIcons.sync),
            title: const Text('Import & Export'),
            body: const ImportExportScreen(),
          ),
          PaneItem(
            icon: const Icon(FluentIcons.event_info),
            title: const Text('Event Log'),
            body: const EventLogScreen(),
          ),
        ],
      ),
    );
  }
}
```

### Windows-Specific Features
```dart
// System Tray Integration
class WindowsSystemTray {
  static Future<void> initialize() async {
    final SystemTray systemTray = SystemTray();

    await systemTray.initSystemTray(
      title: 'DATEYE',
      iconPath: 'assets/icons/tray_icon.ico',
    );

    final Menu menu = Menu()
      ..buildFrom([
        MenuItemLabel(
          label: 'Show',
          onClicked: (_) => _showWindow(),
        ),
        MenuSeparator(),
        MenuItemLabel(
          label: 'Import Files...',
          onClicked: (_) => _quickImport(),
        ),
        MenuSeparator(),
        MenuItemLabel(
          label: 'Exit',
          onClicked: (_) => _exitApp(),
        ),
      ]);

    await systemTray.setContextMenu(menu);
  }
}
```

## macOS Implementation (Priority 2)

### Dependencies
```yaml
dependencies:
  macos_ui: ^2.0.0
  macos_window_utils: ^1.0.0
```

### App Structure
```dart
// presentation/macos/app.dart
import 'package:macos_ui/macos_ui.dart';

class MacOSDateyeApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MacosApp(
      title: 'DATEYE',
      theme: MacosThemeData.light().copyWith(
        primaryColor: CupertinoColors.systemTeal,
      ),
      darkTheme: MacosThemeData.dark().copyWith(
        primaryColor: CupertinoColors.systemTeal,
      ),
      home: MacOSShell(),
      localizationsDelegates: [
        ...AppLocalizations.localizationsDelegates,
      ],
    );
  }
}
```

### macOS Window with Sidebar
```dart
// presentation/macos/screens/shell.dart
class MacOSShell extends StatefulWidget {
  @override
  _MacOSShellState createState() => _MacOSShellState();
}

class _MacOSShellState extends State<MacOSShell> {
  int _pageIndex = 0;

  @override
  Widget build(BuildContext context) {
    return PlatformMenuBar(
      menus: createMenus(),
      child: MacosWindow(
        sidebar: Sidebar(
          minWidth: 200,
          builder: (context, scrollController) {
            return SidebarItems(
              currentIndex: _pageIndex,
              onChanged: (i) => setState(() => _pageIndex = i),
              items: [
                const SidebarItem(
                  leading: MacosIcon(CupertinoIcons.home),
                  label: Text('Dashboard'),
                ),
                const SidebarItem(
                  leading: MacosIcon(CupertinoIcons.arrow_2_circlepath),
                  label: Text('Import & Export'),
                ),
                const SidebarItem(
                  leading: MacosIcon(CupertinoIcons.list_bullet),
                  label: Text('Event Log'),
                ),
              ],
            );
          },
          bottom: MacosListTile(
            leading: const MacosIcon(CupertinoIcons.settings),
            title: const Text('Settings'),
            onClick: () => _navigateToSettings(),
          ),
        ),
        child: IndexedStack(
          index: _pageIndex,
          children: const [
            DashboardScreen(),
            ImportExportScreen(),
            EventLogScreen(),
          ],
        ),
      ),
    );
  }
}
```

## Linux Implementation (Priority 3)

### Dependencies
```yaml
dependencies:
  yaru: ^1.0.0
  yaru_icons: ^2.0.0
```

### App Structure
```dart
// presentation/linux/app.dart
import 'package:yaru/yaru.dart';

class LinuxDateyeApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return YaruTheme(
      builder: (context, yaru, child) {
        return MaterialApp(
          title: 'DATEYE',
          theme: yaru.theme,
          darkTheme: yaru.darkTheme,
          home: LinuxShell(),
          localizationsDelegates: [
            ...AppLocalizations.localizationsDelegates,
          ],
        );
      },
    );
  }
}
```

### Linux Navigation
```dart
// presentation/linux/screens/shell.dart
class LinuxShell extends StatefulWidget {
  @override
  _LinuxShellState createState() => _LinuxShellState();
}

class _LinuxShellState extends State<LinuxShell> {
  int _selectedIndex = 0;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('DATEYE'),
        actions: [
          IconButton(
            icon: const Icon(YaruIcons.settings),
            onPressed: () => _navigateToSettings(),
          ),
        ],
      ),
      body: Row(
        children: [
          NavigationRail(
            selectedIndex: _selectedIndex,
            onDestinationSelected: (i) => setState(() => _selectedIndex = i),
            labelType: NavigationRailLabelType.all,
            destinations: const [
              NavigationRailDestination(
                icon: Icon(YaruIcons.home),
                label: Text('Dashboard'),
              ),
              NavigationRailDestination(
                icon: Icon(YaruIcons.sync),
                label: Text('Import & Export'),
              ),
              NavigationRailDestination(
                icon: Icon(YaruIcons.format_list_bulleted),
                label: Text('Event Log'),
              ),
            ],
          ),
          const VerticalDivider(thickness: 1, width: 1),
          Expanded(
            child: IndexedStack(
              index: _selectedIndex,
              children: const [
                DashboardScreen(),
                ImportExportScreen(),
                EventLogScreen(),
              ],
            ),
          ),
        ],
      ),
    );
  }
}
```

## Shared State Management

All platforms utilize unified BLoC/Cubit state management:

```dart
// presentation/shared/bloc/import/import_cubit.dart
class ImportCubit extends Cubit<ImportState> {
  final ImportService _importService;

  ImportCubit(this._importService) : super(ImportState.initial());

  Future<void> importFile(String path) async {
    emit(state.copyWith(isProcessing: true));

    try {
      final result = await _importService.processFile(path);
      emit(state.copyWith(
        isProcessing: false,
        lastImportResult: result,
      ));
    } catch (e) {
      emit(state.copyWith(
        isProcessing: false,
        error: e.toString(),
      ));
    }
  }
}
```

## Platform-Aware Components

### Dialog Implementation
```dart
// presentation/shared/widgets/platform_dialog.dart
class PlatformDialog {
  static Future<bool?> showConfirmation({
    required BuildContext context,
    required String title,
    required String content,
  }) {
    if (Platform.isWindows) {
      return fluent.showDialog<bool>(
        context: context,
        builder: (context) => fluent.ContentDialog(
          title: Text(title),
          content: Text(content),
          actions: [
            fluent.Button(
              child: const Text('Cancel'),
              onPressed: () => Navigator.of(context).pop(false),
            ),
            fluent.FilledButton(
              child: const Text('Confirm'),
              onPressed: () => Navigator.of(context).pop(true),
            ),
          ],
        ),
      );
    } else if (Platform.isMacOS) {
      return showMacosAlertDialog<bool>(
        context: context,
        builder: (context) => MacosAlertDialog(
          appIcon: const FlutterLogo(size: 56),
          title: Text(title),
          message: Text(content),
          primaryButton: PushButton(
            controlSize: ControlSize.large,
            onPressed: () => Navigator.of(context).pop(true),
            child: const Text('Confirm'),
          ),
          secondaryButton: PushButton(
            controlSize: ControlSize.large,
            onPressed: () => Navigator.of(context).pop(false),
            child: const Text('Cancel'),
          ),
        ),
      );
    } else {
      // Linux (Yaru/Material)
      return showDialog<bool>(
        context: context,
        builder: (context) => AlertDialog(
          title: Text(title),
          content: Text(content),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(false),
              child: const Text('Cancel'),
            ),
            TextButton(
              onPressed: () => Navigator.of(context).pop(true),
              child: const Text('Confirm'),
            ),
          ],
        ),
      );
    }
  }
}
```

## Dependencies

```yaml
dependencies:
  # Core
  flutter:
    sdk: flutter
  flutter_bloc: ^8.1.0
  freezed_annotation: ^2.4.0
  json_annotation: ^4.8.0
  get_it: ^7.6.0
  injectable: ^2.3.0

  # Platform UI
  fluent_ui: ^4.7.0          # Windows
  macos_ui: ^2.0.0           # macOS
  yaru: ^1.0.0               # Linux

  # Platform Integration
  window_manager: ^0.3.0
  system_tray: ^2.0.0
  path_provider: ^2.1.0

  # Functionality
  watcher: ^1.1.0
  encrypt: ^5.0.0
  dio: ^5.3.0

dev_dependencies:
  flutter_test:
    sdk: flutter
  build_runner: ^2.4.0
  freezed: ^2.4.0
  json_serializable: ^6.7.0
  injectable_generator: ^2.4.0
```

## Testing Strategy

### Platform-Specific Testing
```dart
// test/windows/dashboard_screen_test.dart
testWidgets('Windows Dashboard shows correct navigation', (tester) async {
  await tester.pumpWidget(
    FluentApp(
      home: WindowsDashboardScreen(),
    ),
  );

  expect(find.byType(NavigationView), findsOneWidget);
  expect(find.byIcon(FluentIcons.home), findsOneWidget);
});
```

### Shared Logic Testing
```dart
// test/shared/bloc/import_cubit_test.dart
blocTest<ImportCubit, ImportState>(
  'emits success when import completes',
  build: () => ImportCubit(mockImportService),
  act: (cubit) => cubit.importFile('test.xml'),
  expect: () => [
    ImportState(isProcessing: true),
    ImportState(isProcessing: false, lastResult: success),
  ],
);
```

## Build and Deployment

### Windows Build
```bash
flutter build windows --release
# Output: build/windows/runner/Release/
```

### macOS Build
```bash
flutter build macos --release
# Output: build/macos/Build/Products/Release/DATEYE.app
```

### Linux Build
```bash
flutter build linux --release
# Output: build/linux/x64/release/bundle/
```

## Responsive Design Considerations

Window size adaptation for desktop environments:

```dart
class ResponsiveBuilder extends StatelessWidget {
  final Widget Function(BuildContext, BoxConstraints) builder;

  const ResponsiveBuilder({required this.builder});

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        // Provide different layouts based on window size
        return builder(context, constraints);
      },
    );
  }
}
```

## Implementation Guidelines

1. **Platform Detection**: Use `Platform.isX` for runtime platform checks
2. **Conditional Imports**: Implement conditional imports for platform-specific code
3. **Business Logic Separation**: Maintain all business logic in the core layer
4. **Design Guidelines**: Follow platform-specific design conventions
5. **Cross-Platform Testing**: Test on all target platforms before release

## Related Documentation

- [Architecture](architecture.md) - System architecture overview
- [Design System](ui-design/design-system.md) - Platform-aware design specifications
- [Adapter Development](adapter-development.md) - Device adapter implementation
- [Data Formats](data-formats.md) - JSON structure specifications


FILE: architecture/dependency-injection.md
==================================================

# Dependency Injection in DATEYE

Technical implementation of dependency injection using GetIt and Injectable for component lifecycle management.

## Overview

DATEYE implements Dependency Injection (DI) using GetIt as service locator and Injectable for code generation. This architecture ensures testability, modularity, and maintainable component dependencies.

## Dependency Injection Rationale

### Traditional Approach - Limitations
```dart
class TopconAdapter {
  // Hard-coded dependencies
  final parser = XmlParser();        // Untestable
  final logger = FileLogger();       // Cannot disable
  final crypto = AesCrypto();       // Forces encryption in tests
}
```

### DI Approach - Benefits
```dart
@injectable
class TopconAdapter {
  // Constructor injection
  const TopconAdapter(
    this._parser,
    this._logger,
    this._crypto,
  );

  final IXmlParser _parser;    // Mockable interface
  final ILogger _logger;       // Configurable implementation
  final ICrypto _crypto;       // Testable abstraction
}
```

## Service Container Architecture

GetIt provides service location and instance management:

```dart
// Automatic registration via annotations
getIt.registerFactory<IXmlParser>(() => XmlParser());
getIt.registerSingleton<ILogger>(FileLogger());

// Automatic resolution in constructors
final parser = getIt<IXmlParser>();  // Returns configured instance
```

## Annotation System

### @injectable
Registers class for dependency injection:
```dart
@injectable
class PatientService {
  // Registered as PatientService type
}
```

### @Singleton
Ensures single instance throughout application lifecycle:
```dart
@Singleton(as: ILogger)
class FileLogger implements ILogger {
  // Shared instance across all consumers
}
```

### @Named
Differentiates multiple implementations of same interface:
```dart
@Named('topcon_myah')
@Singleton(as: ImportAdapter)
class TopconMyahAdapter implements ImportAdapter {
  // Resolution: getIt<ImportAdapter>(instanceName: 'topcon_myah')
}
```

## Implementation Examples

### Adapter Registration Pattern
```dart
// Self-registering import adapter
@Named('topcon_myah')
@Singleton(as: ImportAdapter)
class TopconMyahImportAdapter implements ImportAdapter {
  const TopconMyahImportAdapter(this._parser);
  final IXmlParser _parser;  // Automatically injected
}

// Alternative implementation
@Named('eye_office')
@Singleton(as: ImportAdapter)
class EyeOfficeImportAdapter implements ImportAdapter {
  const EyeOfficeImportAdapter(this._jsonParser);
  final IJsonParser _jsonParser;  // Different dependency type
}
```

### Repository Pattern with DI
```dart
// Repository receives all adapters
@injectable
class ImportingRepository {
  final Map<String, ImportAdapter> _adapters;

  // GetIt injects all ImportAdapter implementations
  ImportingRepository(this._adapters);

  Future<void> importFile(String adapterId, String path) async {
    final adapter = _adapters[adapterId];
    if (adapter == null) throw UnknownAdapterException();

    await adapter.parse(path);
  }
}
```

### Testing with Dependency Injection
```dart
// Unit test with mocked dependencies
test('imports valid file', () async {
  // Arrange
  final mockParser = MockXmlParser();
  final adapter = TopconMyahImportAdapter(mockParser);

  when(mockParser.parse(any)).thenReturn(testData);

  // Act
  final result = await adapter.parse('test.xml');

  // Assert
  expect(result, isNotNull);
  verify(mockParser.parse('test.xml')).called(1);
});
```

## Implementation Guidelines

### Recommended Practices
- Use interface abstractions for all dependencies
- Apply @Named annotation for adapter identification
- Use @Singleton for stateless service components
- Maintain simple constructors - dependency storage only

### Anti-patterns to Avoid
- Direct GetIt usage in business logic
- Manual instantiation of classes with dependencies
- Mutable state in singleton instances
- Missing build_runner execution after changes

## Code Generation Configuration

Dependency injection requires build-time code generation:

```bash
# Single build execution
dart run build_runner build

# Continuous build during development
dart run build_runner watch

# Clean and rebuild
dart run build_runner build --delete-conflicting-outputs
```

## Common Issues and Solutions

### Resolution Failures

**Issue**: "GetIt: Object not found"
- Verify @injectable annotation present
- Execute build_runner
- Confirm registration name matches

**Issue**: "Cannot inject abstract class"
- Register concrete implementation: `@Singleton(as: ILogger)`
- Ensure implementation class exists

**Issue**: "Circular dependency detected"
- Refactor to eliminate circular references
- Consider lazy injection pattern
- Review architectural dependencies

## Architecture Benefits

1. **Testability**: Isolated component testing with mocks
2. **Flexibility**: Simple addition of new implementations
3. **Maintainability**: Explicit dependency declaration
4. **Consistency**: Standardized dependency management

## Related Documentation

- [Adapter Development](../adapter-development.md) - Creating adapters with DI
- [Architecture](../architecture.md) - System design overview
- [Testing Guide](../testing.md) - Mock injection strategies


FILE: architecture/encryption.md
==================================================

# Data Encryption in DATEYE

Implementation specification for patient data encryption and privacy protection.

## Overview

DATEYE implements data separation to achieve:
- **Privacy Protection**: Encrypted patient identities
- **Research Capability**: Anonymous measurement sharing
- **GDPR Compliance**: Personal data protection
- **Performance**: Fast measurement access

## Current Status

**NOT YET IMPLEMENTED** - Critical priority before production deployment.

Patient data is currently stored unencrypted. Implementation required before processing real patient data.

## Encryption Architecture

```
identity.enc (ENCRYPTED)          log.ndjson (PLAINTEXT)
â”œâ”€â”€ Patient Names                 â”œâ”€â”€ Anonymous ID: pat_001
â”œâ”€â”€ Birth Dates                   â”œâ”€â”€ Measurements
â””â”€â”€ Contact Info                  â””â”€â”€ Events
        â†“                                    â†“
   Encrypted with                    No personal data
   identity.key                      Only references
```

## Implementation Plan

### 1. Encryption Service

```dart
@singleton
class EncryptionService {
  static const _keyFileName = 'identity.key';
  late final Encrypter _encrypter;
  late final Key _key;

  Future<void> initialize() async {
    _key = await _loadOrGenerateKey();
    _encrypter = Encrypter(AES(_key, mode: AESMode.cbc));
  }

  String encryptPatient(Map<String, dynamic> patientData) {
    final plainText = jsonEncode(patientData);
    final iv = IV.fromSecureRandom(16);
    final encrypted = _encrypter.encrypt(plainText, iv: iv);

    // Store IV with encrypted data
    return jsonEncode({
      'iv': iv.base64,
      'data': encrypted.base64,
    });
  }

  Map<String, dynamic> decryptPatient(String encryptedJson) {
    final json = jsonDecode(encryptedJson);
    final iv = IV.fromBase64(json['iv']);
    final encrypted = Encrypted.fromBase64(json['data']);

    final decrypted = _encrypter.decrypt(encrypted, iv: iv);
    return jsonDecode(decrypted);
  }
}
```

### 2. Key Generation Implementation

```dart
Future<Key> _loadOrGenerateKey() async {
  final appDir = await getApplicationSupportDirectory();
  final keyFile = File('${appDir.path}/secure/$_keyFileName');

  if (await keyFile.exists()) {
    // Load existing key
    final keyHex = await keyFile.readAsString();
    return Key.fromBase16(keyHex.trim());
  }

  // Generate new key
  final key = Key.fromSecureRandom(32); // 256-bit
  await _showKeyBackupDialog(key);

  // Save after user confirms backup
  await keyFile.create(recursive: true);
  await keyFile.writeAsString(key.base16);

  // Set file permissions (Unix-like systems)
  if (Platform.isLinux || Platform.isMacOS) {
    await Process.run('chmod', ['600', keyFile.path]);
  }

  return key;
}
```

### 3. Key Backup Dialog

```dart
Future<void> _showKeyBackupDialog(Key key) async {
  // Create temporary file with key
  final desktop = await getDesktopDirectory();
  final tempFile = File('${desktop.path}/DATEYE-RECOVERY-KEY.txt');

  await tempFile.writeAsString('''
DATEYE Encryption Key
=====================
IMPORTANT: Back up this file externally then delete it.

Key: ${key.base16}

Created: ${DateTime.now().toIso8601String()}
Installation: ${await getInstallationId()}

WARNING: Without this key, patient data cannot be recovered.
''');

  // Show dialog
  await showDialog(
    context: context,
    barrierDismissible: false,
    builder: (context) => AlertDialog(
      title: Text('IMPORTANT: Back Up Encryption Key'),
      content: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Text('Your encryption key has been created:'),
          Text(tempFile.path, style: TextStyle(fontFamily: 'monospace')),
          SizedBox(height: 16),
          Text('REQUIRED ACTIONS:', style: TextStyle(fontWeight: FontWeight.bold)),
          Text('1. Open the file'),
          Text('2. Copy the contents'),
          Text('3. Store securely (USB drive, safe)'),
          Text('4. Do NOT store in cloud/email/photos'),
        ],
      ),
      actions: [
        TextButton(
          onPressed: () => openFile(tempFile.path),
          child: Text('Open File'),
        ),
        ElevatedButton(
          onPressed: () async {
            Navigator.of(context).pop();
            // Delete after 48 hours
            Future.delayed(Duration(hours: 48), () async {
              if (await tempFile.exists()) {
                await tempFile.delete();
              }
            });
          },
          child: Text('I Have Backed Up The Key'),
        ),
      ],
    ),
  );
}
```

### 4. Data Storage Pattern

```dart
// Save patient with encryption
class PatientRepository {
  final EncryptionService _encryption;

  Future<void> savePatient(Patient patient) async {
    // Generate anonymous ID
    final secretId = 'pat_${DateTime.now().millisecondsSinceEpoch}';

    // Encrypt identity
    final identity = {
      'firstName': patient.firstName,
      'lastName': patient.lastName,
      'birthDate': patient.birthDate,
      'externalIds': patient.externalIds,
    };

    final encrypted = _encryption.encryptPatient(identity);

    // Save to identity.enc
    await _identityStorage.save(secretId, encrypted);

    // Return anonymous reference
    return secretId;
  }
}

// Log events with anonymous ID only
class EventLogger {
  Future<void> logImport(String secretPid, List<Measurement> measurements) async {
    await _database.insert(LogEntry(
      type: 'import',
      secretPid: secretPid,  // Only anonymous ID
      measurements: measurements,
      timestamp: DateTime.now(),
    ));
  }
}
```

## Security Considerations

### Protected Data
- Patient names, birth dates, addresses
- Personally identifiable information
- External IDs that could identify patients

### Unencrypted Data
- Measurements (anonymized)
- Event logs (anonymized)
- Device configurations
- Application settings

### Key Management Strategy

**Implementation approach:**
1. Automatic key generation on first start
2. Temporary file creation on desktop
3. User acknowledgment required for backup
4. Automatic deletion after 48 hours
5. Permanent storage in secure directory

**User responsibilities:**
- Backup recovery key externally
- Secure storage (physical media)
- Delete temporary file

### Recovery Process

Key recovery procedure:
1. Locate backup recovery key
2. Place in: `[AppData]/DATEYE/secure/identity.key`
3. Restart DATEYE
4. Patient data accessible

Without the key: **All patient data is permanently inaccessible.**

## Implementation Timeline

### Phase 1: Prototype (Current)
- No encryption
- Development/testing only
- No real patient data

### Phase 2: Pre-Production (Required)
- Encryption service implementation
- Key generation with backup flow
- Encrypted identity storage
- Data migration tool

### Phase 3: Production
- Mandatory encryption
- Audit logging
- Key rotation capability (future)

## Testing

```dart
test('patient data encryption', () async {
  final service = EncryptionService();
  await service.initialize();

  final patient = {
    'firstName': 'Test',
    'lastName': 'Patient',
    'birthDate': '2000-01-01',
  };

  final encrypted = service.encryptPatient(patient);

  // Verify no plaintext
  expect(encrypted.contains('Test'), false);
  expect(encrypted.contains('Patient'), false);

  // Verify decryption
  final decrypted = service.decryptPatient(encrypted);
  expect(decrypted['firstName'], 'Test');
});
```

## Compliance Implementation

This implementation addresses:
- **GDPR Article 32**: Technical protection measures
- **Pseudonymization**: Personal data separation
- **Data Portability**: Encrypted export capability
- **Right to Erasure**: Individual record deletion

## Related Documentation

- [Architecture](../architecture.md) - Security architecture
- [Data Formats](../data-formats.md) - File structure specifications
- [Deployment](../deployment.md) - Security configuration


FILE: architecture/project-structure.md
==================================================

# DATEYE Project Structure

Clean Architecture implementation for maintainable medical software development.

## Overview

DATEYE implements Clean Architecture principles with clear separation of concerns across three distinct layers:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Presentation Layer              â”‚  Flutter UI
â”‚         (UI & State Management)         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚         Infrastructure Layer            â”‚  Technical Implementation
â”‚         (Adapters & Data Access)        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚            Core Layer                   â”‚  Business Logic
â”‚         (Entities & Use Cases)          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Dependency Rule

The fundamental architectural rule: **Dependencies only point inward**

- Presentation â†’ Infrastructure â†’ Core (Allowed)
- Core â†’ Infrastructure (Prohibited)
- Infrastructure â†’ Presentation (Prohibited)

## Layer Specifications

### Core Layer (`lib/core/`)

Pure business logic with zero external dependencies.

```
core/
â”œâ”€â”€ entities/           # Business objects
â”‚   â”œâ”€â”€ exam/          # Examination data models
â”‚   â”œâ”€â”€ import/        # Import-related entities
â”‚   â””â”€â”€ export/        # Export-related entities
â”œâ”€â”€ repositories/      # Repository interfaces (contracts)
â”‚   â”œâ”€â”€ i_importing_repository.dart
â”‚   â””â”€â”€ i_exporting_repository.dart
â”œâ”€â”€ usecases/          # Business rules/operations
â”‚   â”œâ”€â”€ import/        # Import operations
â”‚   â”œâ”€â”€ export/        # Export operations
â”‚   â””â”€â”€ settings/      # Settings management
â””â”€â”€ errors/            # Domain-specific errors
```

**Entity Example:**
```dart
// core/entities/exam/axial_length.dart
@freezed
class AxialLength with _$AxialLength {
  const factory AxialLength({
    required String eye,
    required double value,
  }) = _AxialLength;
}
```

**Use Case Example:**
```dart
// core/usecases/import/import_file.dart
@injectable
class ImportFile {
  final IImportingRepository _repository;

  const ImportFile(this._repository);

  Future<Either<Failure, ImportResult>> call(String filePath) async {
    // Pure business logic - no UI, no file access
    return _repository.importFile(filePath);
  }
}
```

### Infrastructure Layer (`lib/infrastructure/`)

Technical implementation details and external system integration.

```
infrastructure/
â”œâ”€â”€ adapters/          # Device adapters (Topcon, etc.)
â”‚   â”œâ”€â”€ topcon_myah_import_adapter.dart
â”‚   â””â”€â”€ i_import_adapter.dart
â”œâ”€â”€ datasources/       # Data access (files, network)
â”‚   â”œâ”€â”€ logging_datasource.dart
â”‚   â””â”€â”€ importing_datasource.dart
â”œâ”€â”€ repositories/      # Repository implementations
â”‚   â”œâ”€â”€ importing_repository.dart
â”‚   â””â”€â”€ exporting_repository.dart
â”œâ”€â”€ models/            # Data transfer objects
â”‚   â””â”€â”€ import/
â”‚       â””â”€â”€ imported_data_file_model.dart
â””â”€â”€ storage/           # File/database access
    â””â”€â”€ database/
        â””â”€â”€ json_file_storage_database.dart
```

**Repository Implementation Example:**
```dart
// infrastructure/repositories/importing_repository.dart
@Injectable(as: IImportingRepository)
class ImportingRepository implements IImportingRepository {
  final IDatabase _database;
  final Map<String, ImportAdapter> _adapters;

  const ImportingRepository(this._database, this._adapters);

  @override
  Future<Either<Failure, ImportResult>> importFile(String path) async {
    // Technical implementation using adapters and database
  }
}
```

### Presentation Layer (`lib/presentation/`)

Flutter-specific UI implementation.

```
presentation/
â”œâ”€â”€ bloc/              # State management
â”‚   â”œâ”€â”€ import/        # Import-related cubits
â”‚   â”œâ”€â”€ export/        # Export-related cubits
â”‚   â””â”€â”€ dashboard/     # Dashboard state
â”œâ”€â”€ pages/             # Screen widgets
â”‚   â”œâ”€â”€ dashboard/
â”‚   â”œâ”€â”€ import_settings/
â”‚   â””â”€â”€ export_settings/
â”œâ”€â”€ widgets/           # Reusable UI components
â”‚   â”œâ”€â”€ common/
â”‚   â””â”€â”€ dialogs/
â””â”€â”€ theme/             # App theming
```

**Page with BLoC Example:**
```dart
// presentation/pages/dashboard/dashboard_page.dart
class DashboardPage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return BlocBuilder<DashboardCubit, DashboardState>(
      builder: (context, state) {
        // Pure UI code - no business logic
        return Scaffold(
          body: EventList(events: state.recentEvents),
        );
      },
    );
  }
}
```

## File Organization Patterns

### Feature-First Organization

Code organized by feature within each layer:

```
usecases/
â”œâ”€â”€ import/
â”‚   â”œâ”€â”€ import_file.dart
â”‚   â”œâ”€â”€ validate_import.dart
â”‚   â””â”€â”€ get_import_history.dart
â”œâ”€â”€ export/
â”‚   â”œâ”€â”€ export_data.dart
â”‚   â””â”€â”€ retry_failed_export.dart
â””â”€â”€ settings/
    â”œâ”€â”€ update_language.dart
    â””â”€â”€ toggle_auto_import.dart
```

### Naming Conventions

- **Interfaces**: Prefix with `I` (e.g., `IImportAdapter`)
- **Implementations**: No prefix (e.g., `ImportingRepository`)
- **Models**: Suffix with `Model` (e.g., `ImportedDataFileModel`)
- **Use Cases**: Verb phrases (e.g., `ImportFile`, `GetPatientData`)

## Dependency Injection Structure

```
injection.dart         # DI configuration
â”œâ”€â”€ @injectableInit   # Auto-generated initialization
â””â”€â”€ GetIt instance    # Service locator
```

## Architectural Benefits

### 1. Testability
Independent layer testing:
```dart
// Test use case without UI or file system
test('ImportFile validates file path', () {
  final mockRepo = MockImportingRepository();
  final useCase = ImportFile(mockRepo);
  // Test pure business logic
});
```

### 2. Maintainability
- Rapid code location by feature and layer
- Isolated change impact
- Clear architectural boundaries

### 3. Scalability
- Feature addition without existing code modification
- Parallel development capability
- Simplified onboarding process

### 4. Flexibility
- UI framework replacement capability
- Storage mechanism changes
- Preserved business logic

## Common Implementation Patterns

### Repository Pattern
```dart
// Core defines interface
abstract class IPatientRepository {
  Future<Patient> getPatient(String id);
}

// Infrastructure implements
class PatientRepository implements IPatientRepository {
  @override
  Future<Patient> getPatient(String id) {
    // Implementation details
  }
}
```

### Use Case Pattern
```dart
// Single responsibility - one operation
class GetPatientMeasurements {
  Future<List<Measurement>> call(String patientId) {
    // Business logic only
  }
}
```

### Error Handling Flow
```dart
// Error propagation through layers
Infrastructure Error â†’ Domain Failure â†’ UI Error Message
```

## Implementation Guidelines

### Recommended Practices
- Maintain layer independence
- Utilize dependency injection
- Test layers independently
- Follow naming conventions
- One class per file

### Practices to Avoid
- UI imports in Core layer
- Business logic in UI components
- Direct layer bypassing (UI â†’ Database)
- Mixed concerns in single class

## Related Documentation

- [Architecture](../architecture.md) - System design overview
- [Dependency Injection](dependency-injection.md) - DI implementation
- [State Management](state-management.md) - BLoC pattern
- [Testing Guide](../testing.md) - Layer testing strategies


FILE: architecture/state-management.md
==================================================

# State Management in DATEYE

Implementation of reactive state management using BLoC pattern for UI synchronization and data flow.

## Overview

DATEYE implements the BLoC (Business Logic Component) pattern for state management, providing:
- **Reactive UI Updates**: Automatic synchronization with data changes
- **Separation of Concerns**: Business logic isolation from presentation
- **Predictable State**: Testable and debuggable state transitions

## State Architecture

### Dual-Layer State System

**1. Persistent State (File System)**
```
log.ndjson             â†’ Event history
importingDevice.ndjson â†’ Device configurations
appConfigs.ndjson      â†’ Application settings
```

**2. UI State (Memory)**
```dart
class DashboardState {
  final List<RecentEvent> recentEvents;  // Recent activity
  final ImportProgress? activeImport;     // Current operation
  final bool isLoading;                   // Loading indicator
  final String? error;                    // Error state
}
```

### Data Flow Architecture

```
File Changes â†’ File Watcher â†’ Cubit â†’ State â†’ UI Updates
     â†“                           â†‘
User Action â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## BLoC Pattern Implementation

### Cubit Architecture

Cubit provides simplified state management:

```dart
class ImporterListenerCubit extends Cubit<ImporterListenerState> {
  ImporterListenerCubit() : super(ImporterListenerState.initial());

  // State transition method
  void startImport(String filePath) {
    emit(state.copyWith(isImporting: true));
    // Import processing
    emit(state.copyWith(isImporting: false));
  }
}
```

### Immutable State Principle

State objects are immutable and replaced atomically:

```dart
// Incorrect - Direct state mutation
state.devices.add(newDevice);

// Correct - State replacement
emit(state.copyWith(
  devices: [...state.devices, newDevice],
));
```

## Implementation Examples

### Real-time Dashboard Updates

```dart
// File system monitoring integration
class DashboardCubit extends Cubit<DashboardState> {
  StreamSubscription? _eventWatcher;

  void startWatching() {
    _eventWatcher = _database.watchAll<LogEntry>().listen((events) {
      // Automatic UI synchronization
      emit(state.copyWith(recentEvents: events));
    });
  }
}

// Reactive UI component
BlocBuilder<DashboardCubit, DashboardState>(
  builder: (context, state) {
    return EventList(events: state.recentEvents);
  },
)
```

### Progress Tracking Implementation

```dart
// Progress state model
class ImportState {
  final String? currentFile;
  final int processedCount;
  final int totalCount;
  double get progress => processedCount / totalCount;
}

// UI progress indicator
LinearProgressIndicator(value: state.progress)
```

### Error State Management

```dart
// Error handling in Cubit
Future<void> importFile(String path) async {
  try {
    emit(state.copyWith(isLoading: true, error: null));
    await _importService.import(path);
    emit(state.copyWith(isLoading: false, success: true));
  } catch (e) {
    emit(state.copyWith(
      isLoading: false,
      error: 'Import operation failed: ${e.toString()}',
    ));
  }
}

// Error presentation in UI
if (state.error != null) {
  ScaffoldMessenger.of(context).showSnackBar(
    SnackBar(content: Text(state.error!)),
  );
}
```

## File System Integration

Reactive file monitoring with BLoC:

```dart
// Database stream provider
Stream<List<LogEntry>> watchLogs() {
  return _database.watchAll<LogEntry>(
    adapter: LogEntryAdapter(),
    limit: 50,
  );
}

// Cubit subscription management
class LogViewerCubit extends Cubit<LogViewerState> {
  void initialize() {
    _database.watchLogs().listen((logs) {
      emit(state.copyWith(logs: logs));
    });
  }
}
```

## Testing Strategies

### Unit Testing Cubits

```dart
test('import operation updates state correctly', () async {
  // Arrange
  final cubit = ImportCubit(mockImportService);

  // Act
  await cubit.importFile('test.xml');

  // Assert
  expect(cubit.state.isLoading, false);
  expect(cubit.state.success, true);
});
```

### BLoC Test Package Integration

```dart
blocTest<ImportCubit, ImportState>(
  'emits loading followed by success state',
  build: () => ImportCubit(mockService),
  act: (cubit) => cubit.importFile('test.xml'),
  expect: () => [
    ImportState(isLoading: true),
    ImportState(isLoading: false, success: true),
  ],
);
```

## Implementation Guidelines

### Recommended Practices
- Maintain state immutability using Freezed
- Use descriptive state class names
- Implement comprehensive state coverage (loading, success, error)
- Properly dispose StreamSubscriptions in close()

### Anti-patterns
- Business logic in UI components
- Direct state mutation
- Missing error state handling
- Storing sensitive data in UI state

## Project Organization

```
presentation/
  bloc/
    dashboard/
      dashboard_cubit.dart      # State management logic
      dashboard_state.dart      # State model definition
    import/
      import_cubit.dart
      import_state.dart
    export/
      export_cubit.dart
      export_state.dart
```

## Medical Application Benefits

1. **Real-time Monitoring**: Live import/export status
2. **Progress Visualization**: Operation progress tracking
3. **Error Transparency**: Clear error state presentation
4. **Data Consistency**: Synchronized multi-screen state
5. **Professional Interface**: Responsive user experience

## Related Documentation

- [Architecture](../architecture.md) - System design overview
- [Flutter Implementation](../flutter-implementation.md) - UI implementation patterns
- [Data Formats](../data-formats.md) - Persistent state specifications


FILE: ui-design/README.md
==================================================

# DATEYE UI Design Documentation

Design documentation for the DATEYE desktop application for medical device integration.

## Design Philosophy

DATEYE follows the principle of invisible excellence: The user interface supports medical workflows without interruption while maintaining a professional appearance.

### Core Principles

1. **Clarity**
   - Every element has a clear purpose
   - No purely decorative elements
   - Clear information hierarchy

2. **Simplicity**
   - Clean lines, sufficient whitespace
   - Subtle shadows and depth
   - Professional without sterility

3. **Context Awareness**
   - Adaptation to medical environments
   - Functional on older hardware
   - Readability under various lighting conditions

4. **Reliability**
   - Consistent feedback for every action
   - Clear error states
   - No ambiguities for users

## Visual Direction

### Platform-Native Components

DATEYE uses platform-specific UI components:
- **Windows**: Fluent UI (Windows 11 Design)
- **macOS**: macOS UI (Apple Design Language)
- **Linux**: Yaru (Ubuntu/GNOME Design)

Benefits:
- Familiar operation for users
- Native performance and behavior
- Automatic operating system integration
- Professional appearance for medical applications

### Unified Brand Identity

While respecting platform conventions, DATEYE maintains consistency through:
- Unified teal accent color
- Consistent information architecture
- Identical workflows and functions
- Professional tone for medical environments

## Design System Components

- [Design System](design-system.md) - Colors, typography, spacing
- [User Flows](user-flows.md) - User guidance through the application
- [Screen Designs](screens/) - Detailed specifications

## Platform Considerations

### Desktop-First Design
- Optimized for mouse precision
- Keyboard shortcuts for power users
- Multi-window support
- System tray integration

### Screen Sizes
- Minimum: 1280x720 (older practice computers)
- Optimal: 1920x1080 (modern standard)
- Maximum: 4K support with scaling

## Information Architecture

### Navigation Pattern: Logo + Tab Navigation

DATEYE uses a unified tab navigation model:
- DATEYE logo on the left for brand identity (180Ã—36px)
- Four main tabs in one row: Dashboard, Connections, History, Settings
- Settings integrated as main navigation tab
- Active tab with blue underline (#0087BA)
- Responsive: Statistics hidden on screens <1200px

This pattern maximizes space efficiency while maintaining accessibility to all functions.

## Success Metrics

Success criteria for DATEYE design:
- Training time under 15 minutes
- No ambiguities in critical actions
- Premium appearance without intimidation
- Reliable function on 5-year-old hardware

## Implementation Status

### Completed
- Visual direction: Professional
- Navigation: Top navigation + dashboard (passive)
- Color palette: Teal as primary color
- Typography: Inter
- Core screens designed

### In Progress
- Component library implementation
- Testing with medical staff
- Dark mode preparation for version 2

### Decisions Made
- **System Tray First**: Application runs in background
- **Passive Dashboard**: Status display only, no direct actions
- **Data Management**: Dedicated screen for import/export
- **Minimal Interaction**: Focus on automation rather than manual control



FILE: ui-design/design-system.md
==================================================

# DATEYE Design System

Platform-native design system for professional medical software.

## Platform-Native Approach

DATEYE uses native UI components for each platform to ensure a familiar, professional user experience:

1. **Windows**: Fluent UI (Windows 11 Design Language)
2. **macOS**: macOS UI (Apple Human Interface Guidelines)
3. **Linux**: Yaru (Ubuntu/GNOME Design System)

This strategy ensures:
- Familiar operation for users on their platform
- Native performance and behavior
- Compliance with platform guidelines
- Professional medical quality

## Platform-Specific Design Systems

### Windows (Fluent Design)

The Windows implementation uses Microsoft's Fluent Design System:

```dart
// Windows Theme Configuration
FluentThemeData(
  accentColor: Color(0xFF0087BA), // DATEYE Blue
  brightness: Brightness.light,
  visualDensity: VisualDensity.standard,

  // Fluent-specific elements
  micaBackgroundColor: Color(0xFFF3F3F3),
  acrylicBackgroundColor: Color(0xCC3F3F3F),

  // Typography
  typography: Typography.raw(
    display: TextStyle(fontSize: 68, fontWeight: FontWeight.w600),
    titleLarge: TextStyle(fontSize: 28, fontWeight: FontWeight.w600),
    title: TextStyle(fontSize: 20, fontWeight: FontWeight.w600),
    body: TextStyle(fontSize: 14),
    caption: TextStyle(fontSize: 12),
  ),
);
```

**Fluent Core Components:**
- NavigationView with Top/Left-Pane options
- CommandBar for actions
- ContentDialog for alerts
- Acrylic/Mica materials for depth
- Reveal highlight effects

### macOS (Human Interface)

The macOS implementation follows Apple's design language:

```dart
// macOS Theme Configuration
MacosThemeData.light().copyWith(
  primaryColor: Color(0xFF0087BA), // DATEYE Blue

  // macOS-specific colors
  canvasColor: CupertinoColors.systemBackground,
  controlBackgroundColor: CupertinoColors.secondarySystemBackground,
  dividerColor: CupertinoColors.separator,

  // Typography
  typography: MacosTypography(
    largeTitle: TextStyle(fontSize: 26, fontWeight: FontWeight.w400),
    title1: TextStyle(fontSize: 22, fontWeight: FontWeight.w400),
    title2: TextStyle(fontSize: 17, fontWeight: FontWeight.w600),
    headline: TextStyle(fontSize: 14, fontWeight: FontWeight.w600),
    body: TextStyle(fontSize: 13),
    caption1: TextStyle(fontSize: 10),
  ),
);
```

**macOS Core Components:**
- MacosWindow with unified toolbar
- Sidebar navigation
- MacosAlertDialog
- Push/Help buttons
- SF Symbols icons

### Linux (Yaru Design)

The Linux implementation uses Ubuntu's Yaru design:

```dart
// Yaru Theme Configuration
YaruThemeData(
  variant: YaruVariant.prussianGreen, // Closest DATEYE blue variant
  useMaterial3: true,

  // Extension for custom colors
  extensions: [
    YaruColors(
      primary: Color(0xFF0087BA), // DATEYE Blue
      success: Color(0xFF16A34A),
      warning: Color(0xFFEA580C),
      error: Color(0xFFDC2626),
    ),
  ],
);
```

**Yaru Core Components:**
- HeaderBar with integrated controls
- NavigationRail for sidebar
- Yaru icons and indicators
- GNOME-style dialogs
- Rounded corners and shadows

## Unified Brand Identity

While respecting platform conventions, DATEYE maintains brand consistency through:

### Brand Colors
```dart
// Cross-platform semantic colors
class DateyeColors {
  // Brand colors from logo
  static const datGray = Color(0xFFB0B0B0);  // Gray (69% opacity in logo)
  static const eyeBlue = Color(0xFF0087BA);  // Light blue

  // Primary brand color (used as accent)
  static const primary = Color(0xFF0087BA);

  // Status colors
  static const active = Color(0xFF16A34A);   // Green - System running
  static const import = Color(0xFF0087BA);   // Blue - Data coming in
  static const export = Color(0xFFEA580C);   // Orange - Data going out

  // Semantic colors (adapted to platform conventions)
  static const success = Color(0xFF16A34A);
  static const warning = Color(0xFFEA580C);
  static const error = Color(0xFFDC2626);
  static const info = Color(0xFF0EA5E9);
}
```

### Typography Scale
Each platform uses its native font but follows consistent sizes:

| Level | Windows (Segoe UI) | macOS (SF Pro) | Linux (Ubuntu) |
|-------|-------------------|----------------|----------------|
| Display | 68pt | - | 40pt |
| Title Large | 28pt | 26pt | 32pt |
| Title | 20pt | 22pt | 24pt |
| Headline | 14pt | 17pt | 18pt |
| Body | 14pt | 13pt | 14pt |
| Caption | 12pt | 10pt | 12pt |

### Spacing System
Universal 8px grid across all platforms:
```dart
class DateyeSpacing {
  static const double xs = 4;   // 0.5 grid units
  static const double sm = 8;   // 1 grid unit
  static const double md = 16;  // 2 grid units
  static const double lg = 24;  // 3 grid units
  static const double xl = 32;  // 4 grid units
  static const double xxl = 48; // 6 grid units
}
```

## Platform-Aware Components

### Cross-Platform Button Component

```dart
class DateyeButton extends StatelessWidget {
  final String label;
  final VoidCallback onPressed;
  final bool isPrimary;

  const DateyeButton({
    required this.label,
    required this.onPressed,
    this.isPrimary = false,
  });

  @override
  Widget build(BuildContext context) {
    if (Platform.isWindows) {
      return isPrimary
        ? fluent.FilledButton(
            onPressed: onPressed,
            child: Text(label),
          )
        : fluent.Button(
            onPressed: onPressed,
            child: Text(label),
          );
    } else if (Platform.isMacOS) {
      return isPrimary
        ? PushButton(
            buttonSize: ButtonSize.large,
            onPressed: onPressed,
            child: Text(label),
          )
        : MacosTextButton(
            onPressed: onPressed,
            child: Text(label),
          );
    } else {
      // Linux (Material/Yaru)
      return isPrimary
        ? ElevatedButton(
            onPressed: onPressed,
            child: Text(label),
          )
        : TextButton(
            onPressed: onPressed,
            child: Text(label),
          );
    }
  }
}
```

### Platform Dialogs

```dart
class DateyeDialog {
  static Future<bool?> showConfirmation({
    required BuildContext context,
    required String title,
    required String message,
  }) {
    if (Platform.isWindows) {
      return fluent.showDialog<bool>(
        context: context,
        builder: (_) => fluent.ContentDialog(
          title: Text(title),
          content: Text(message),
          actions: [
            fluent.Button(
              child: const Text('Cancel'),
              onPressed: () => Navigator.pop(context, false),
            ),
            fluent.FilledButton(
              child: const Text('Confirm'),
              onPressed: () => Navigator.pop(context, true),
            ),
          ],
        ),
      );
    } else if (Platform.isMacOS) {
      return showMacosAlertDialog<bool>(
        context: context,
        builder: (_) => MacosAlertDialog(
          appIcon: const FlutterLogo(size: 56),
          title: Text(title),
          message: Text(message),
          primaryButton: PushButton(
            buttonSize: ButtonSize.large,
            child: const Text('Confirm'),
            onPressed: () => Navigator.pop(context, true),
          ),
          secondaryButton: MacosTextButton(
            child: const Text('Cancel'),
            onPressed: () => Navigator.pop(context, false),
          ),
        ),
      );
    } else {
      // Linux
      return showDialog<bool>(
        context: context,
        builder: (_) => AlertDialog(
          title: Text(title),
          content: Text(message),
          actions: [
            TextButton(
              child: const Text('Cancel'),
              onPressed: () => Navigator.pop(context, false),
            ),
            TextButton(
              child: const Text('Confirm'),
              onPressed: () => Navigator.pop(context, true),
            ),
          ],
        ),
      );
    }
  }
}
```

## Layout Patterns

### Dashboard Layout
Each platform uses its native navigation pattern:

**Windows**: NavigationView with Top Pane
```dart
NavigationView(
  pane: NavigationPane(
    displayMode: PaneDisplayMode.top,
    items: [...],
  ),
)
```

**macOS**: Sidebar Navigation
```dart
MacosWindow(
  sidebar: Sidebar(
    items: [...],
  ),
)
```

**Linux**: NavigationRail
```dart
Scaffold(
  body: Row(
    children: [
      NavigationRail(...),
      Expanded(child: content),
    ],
  ),
)
```

## Component States

### Interactive States
Consistent across all platforms:
- **Default**: Base appearance
- **Hover**: Subtle highlighting (desktop only)
- **Pressed**: Visual feedback
- **Focused**: Keyboard navigation indicator
- **Disabled**: Reduced opacity

### Loading States
```dart
// Platform-aware progress indicator
class DateyeProgress extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    if (Platform.isWindows) {
      return const fluent.ProgressRing();
    } else if (Platform.isMacOS) {
      return const MacosProgressCircle();
    } else {
      return const CircularProgressIndicator();
    }
  }
}
```

## Theming Strategy

### Light Mode (Standard)
All platforms deliver Light Mode optimized for medical environments:
- High contrast for readability
- Reduced eye strain for long sessions
- Professional appearance

### Dark Mode (Future)
Prepared for v2 implementation:
```dart
// Theme detection
final brightness = MediaQuery.of(context).platformBrightness;
final isDark = brightness == Brightness.dark;
```

## Responsive Design

### Window Size Breakpoints
```dart
class Breakpoints {
  static const double mobile = 600;   // Minimum supported
  static const double tablet = 900;   // Compact layout
  static const double desktop = 1200; // Standard layout
  static const double wide = 1800;    // Extended layout
}
```

### Adaptive Layouts
```dart
class AdaptiveLayout extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final width = MediaQuery.of(context).size.width;

    if (width < Breakpoints.tablet) {
      return CompactLayout();
    } else if (width < Breakpoints.desktop) {
      return StandardLayout();
    } else {
      return WideLayout();
    }
  }
}
```

## Accessibility

### Platform-Specific Requirements

**Windows**:
- Narrator screenreader support
- High contrast mode detection
- Keyboard navigation with F6/Tab

**macOS**:
- VoiceOver support
- Reduce transparency option
- Full keyboard access

**Linux**:
- Orca screenreader support
- High contrast themes
- Focus indicators

### Universal Accessibility
```dart
// Semantic labels for all platforms
Semantics(
  label: 'Import patient data',
  button: true,
  child: DateyeButton(...),
)
```

## Icon Strategy

### Platform Icons
- **Windows**: Fluent Icons
- **macOS**: SF Symbols
- **Linux**: Yaru Icons

### Icon System - Font Awesome 5

DATEYE uses Font Awesome 5 as primary icon system for cross-platform consistency.

#### Font Awesome 5 Rationale
- Consistent design - Unified style across all icons
- Comprehensive library - Over 7,000 icons available (Pro version)
- Professional - Proven in medical and enterprise applications
- Scalable - Vector-based, perfect at all sizes
- Documentation - Excellent docs and community support

#### Icon Categories in DATEYE

| Category | Font Awesome Class | Size | Usage | Color |
|-----------|-------------------|--------|------------|--------|
| Status | `fas fa-*` | 24px | System status indicators | Context-dependent |
| Navigation | `fas fa-*` | 20px | Main navigation | Standard |
| Activity | `fas fa-*` | 14px | Event log icons | Context-dependent |
| Meta | `fas fa-*` | 12px | Additional information | Gray |

#### Used Icons

```css
/* Status Icons */
.fa-check          /* System active - Green */
.fa-download       /* Import Queue - Blue/Teal */
.fa-upload         /* Export Queue - Orange */

/* Activity Icons */
.fa-download       /* Import events - Blue/Teal */
.fa-upload         /* Export events - Orange */
.fa-exclamation-circle  /* Error - Red */

/* Navigation */
.fa-arrows-alt-v   /* Import & Export */
.fa-history        /* Event Log */
.fa-cog            /* Settings */

/* Meta Icons */
.fa-folder         /* Folders/Files */
.fa-check-circle   /* Success */
.fa-users          /* Multiple patients */
.fa-user           /* Single patient */
.fa-plug           /* Network/Device */
.fa-cloud          /* Cloud export */
.fa-chart-bar      /* Statistics */
.fa-ruler          /* Measurements */
.fa-glasses        /* Refraction */
.fa-exclamation-triangle /* Warning */
.fa-redo           /* Retry/Refresh */
```

#### Integration

```html
<!-- Font Awesome 5 Pro (Production) -->
<link rel="stylesheet" href="https://pro.fontawesome.com/releases/v5.15.4/css/all.css"
      integrity="YOUR-INTEGRITY-KEY"
      crossorigin="anonymous">

<!-- Font Awesome 5 Free (Development) -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
```

#### Icon Styles

```css
/* Base styles for all icons */
.status-icon i,
.activity-icon i,
.nav-button i,
.activity-meta i {
    display: inline-block;
    vertical-align: middle;
    line-height: 1;
}

/* Sizes by category */
.status-icon i { font-size: 24px; }
.nav-button i { font-size: 20px; }
.activity-icon i { font-size: 14px; }
.activity-meta i {
    font-size: 12px;
    opacity: 0.7;
}
```

### Fallback Icons
For consistency when platform icons are unavailable:
```dart
class DateyeIcons {
  static IconData get home {
    if (Platform.isWindows) return FluentIcons.home;
    if (Platform.isMacOS) return CupertinoIcons.home;
    return YaruIcons.home;
  }
}
```

## Implementation Guidelines

### 1. Platform Detection
Always check platform at runtime:
```dart
if (Platform.isWindows) {
  // Windows-specific code
} else if (Platform.isMacOS) {
  // macOS-specific code
} else if (Platform.isLinux) {
  // Linux-specific code
}
```

### 2. Conditional Imports
Use conditional imports for smaller bundle size:
```dart
// platform_button.dart
export 'platform_button_stub.dart'
  if (dart.library.io) 'platform_button_io.dart'
  if (dart.library.html) 'platform_button_web.dart';
```

### 3. Testing Strategy
Test on all platforms:
```bash
# Windows
flutter test --platform windows

# macOS
flutter test --platform macos

# Linux
flutter test --platform linux
```

## Performance Considerations

### Platform-Specific Optimizations

**Windows**:
- Use native win32 APIs where beneficial
- Utilize DirectX rendering

**macOS**:
- Metal rendering backend
- Native macOS animations

**Linux**:
- GTK rendering optimizations
- Wayland/X11 compatibility

### Universal Performance Tips
1. Lazy load heavy components
2. Use const constructors
3. Minimize rebuilds with proper state management
4. Profile separately on each platform

## Design Checklist

Before implementing a new component:

- [ ] Design exists for all three platforms
- [ ] Follows platform conventions
- [ ] Maintains DATEYE brand identity
- [ ] Accessible on all platforms
- [ ] Responsive to window sizes
- [ ] Tested with platform-specific tools
- [ ] Performance profiled
- [ ] Documentation complete

## Resources

### Platform Guidelines
- [Fluent Design System](https://www.microsoft.com/design/fluent/)
- [Human Interface Guidelines](https://developer.apple.com/design/)
- [GNOME Human Interface Guidelines](https://developer.gnome.org/hig/)

### Flutter Packages
- [fluent_ui Documentation](https://pub.dev/packages/fluent_ui)
- [macos_ui Documentation](https://pub.dev/packages/macos_ui)
- [yaru Documentation](https://pub.dev/packages/yaru)

## Related Documentation

- [Flutter Implementation](../flutter-implementation.md) - Technical implementation
- [UI Design](README.md) - General design philosophy
- [Architecture](../architecture.md) - System architecture



FILE: ui-design/dashboard/dashboard.md
==================================================

# Dashboard Screen

> Passive status view when DATEYE UI is opened

## Purpose

The dashboard provides a read-only overview of DATEYE's background operations. It appears only when users manually open the UI from the system tray or when attention is required. DATEYE runs silently in the background by default.

## Layout Structure

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                           [_] [â–¡] [x]   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ [LOGO] Dashboard â”‚ Connections â”‚ History â”‚ Settings â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                          â”‚
â”‚  Today's Activity    12 imports â€¢ 8 exports â€¢ 2 errors â”‚
â”‚                                                          â”‚
â”‚                        [All (22)] [Imports (12)]        â”‚
â”‚                        [Exports (8)] [Errors (2)]       â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â”‚
â”‚  [NOW] Importing: MYAH Files (2/3 files) â€¢â€¢â—‹        â”‚
â”‚  [14:32] Import: MYAH â†’ DATEYE - Schmidt_Anna_2024.xml  â”‚
â”‚           Mueller_Hans.xml, Weber_Lisa.xml               â”‚
â”‚  [14:28] Export: DATEYE â†’ AL550 - Anna Schmidt, Hans Mueller â”‚
â”‚  [14:15] Export failed: DATEYE â†’ AL550 - Connection timeout â”‚
â”‚  [14:10] Import: Eye-Office â†’ DATEYE - 15 patients imported â”‚
â”‚  [13:58] Import: IOLMaster â†’ DATEYE - bilateral_exam.dcm â”‚
â”‚  [13:45] Import error: Unknown format - 3 files         â”‚
â”‚  [13:40] Import: Eye-Office â†’ DATEYE - 2 batch files    â”‚
â”‚  [13:35] Export: DATEYE â†’ Cloud - 3 patients            â”‚
â”‚  [13:30] Import: AL550 â†’ DATEYE - Hans Mueller          â”‚
â”‚                                                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ System running â€¢ Last sync: 2 min ago         v2.0.0    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Active Process Display

**Subtle Design:**
- Light blue background (8% opacity) instead of bold card
- Animated progress dots instead of progress bar
- Subtle pulse effect on icon (no rotation)
- Smaller visual footprint
- Still clearly distinguishable with "[NOW]" timestamp

## Visual Design

### Activity Timeline

- **Active Process**: Subtle blue-tinted background with animated dots
- **Regular Activities**: Clean white cards with hover effects
- **Enhanced Details**: Multi-line display with filenames, patient names
- **Visual Hierarchy**: Time â†’ Type â†’ Details â†’ Metadata
- **Monospace Timestamps**: Better alignment and technical feel

### Tab Navigation

- **Logo placement**: DATEYE logo on the left side of tabs
- **Four main tabs**: Dashboard, Connections, History, Settings
- **Active tab**: Pill-style background with light blue tint (#0087BA at 10% opacity)
- **Icons**: Each tab has an icon for better recognition
- **Responsive behavior**:
  - **Desktop (> 1100px)**: Full logo + icons with complete text
  - **Tablet (768-1100px)**: Smaller logo + icons with shortened text ("Connections" â†’ "Connect")
  - **Mobile (< 768px)**: Text only (no logo, no icons), optimized for readability
- **Consistent padding**: 32px left/right at all screen sizes
- Easy switching between main functions
- Settings integrated as fourth tab (no separate icon)

### Minimal Footer

- System status on the left
- Version info on the right
- Clean single-line design
- No navigation buttons (moved to tabs)

### Smart Filtering

- Filter chips show counts: "All (22)", "Import (12)", etc.
- Numbers update dynamically as activities complete
- Quick visual indication of activity distribution
- Helps prioritize attention (e.g., "Errors (2)" draws eye)

### ğŸ–¥ï¸ Interactive Mockup

**[View Windows Fluent UI Dashboard Mockup](dashboard-fluent-ui.html)**

The interactive mockup demonstrates:
- **Logo and tab navigation** in single row for space efficiency
- **Larger logo** (180Ã—36px) for strong brand visibility
- **Responsive navigation** with three distinct breakpoints:
  - **Desktop (>1100px)**: Full logo + icon tabs with complete text
  - **Tablet (768-1100px)**: Smaller logo + icon tabs with shortened "Import" text
  - **Mobile (<768px)**: Text-only navigation (no logo/icons) for optimal readability
- **Four tabs**: Dashboard, Connections, History, Settings
- **Consistent 32px padding** maintained across all window sizes
- Timeline showing all today's activities
- **Mini-statistics** in header (hidden on screens < 1200px)
- **Smart filtering** with activity counts
- Subtle active process indicator with pulse effect
- Fluent Design reveal effects and animations
- Live data simulation with progress dots
- Minimal footer with status
- Auto-scrolling for longer activity lists

## ğŸ¯ Key Features

### 1. Active Process Display
- **Subtle Indicator**: Light blue background (8% opacity)
- **"[NOW]" Timestamp**: Indicates ongoing process
- **Progress Dots**: Visual progress indicator (â€¢â€¢â—‹ = 2/3)
- **Auto-hide**: Disappears when process completes
- **Animated Icon**: Subtle pulse effect shows activity

### 2. Today's Activity Timeline
- All events from today (filtered from log.ndjson)
- **Mini-statistics**: Quick summary in header (X imports â€¢ Y exports â€¢ Z errors)
- Chronological order (newest first)
- **Enhanced details**: Shows filenames, patient names, or counts inline
- No interaction - just information display
- Older events accessible via "History" tab

**Example entries with details:**
```
[14:32] âœ“ Import: Topcon MYAH - Schmidt_Anna_2024.xml, Mueller_Hans.xml, Weber_Lisa.xml
[14:28] âœ“ Export: AL550 - Anna Schmidt, Hans Mueller
[14:15] âš  Export failed â†’ AL550 - Connection timeout (Retry 1/3)
[14:10] âœ“ Import: Eye-Office API - 15 patients synced
[13:58] âœ“ Import: ZEISS IOLMaster - bilateral_exam_2024.dcm
```

### 3. Tab Navigation
- Four main sections easily accessible
- Dashboard always visible as default
- Import & Export for configuration
- History for full activity record
- Settings for app configuration
- DATEYE logo on the left for branding
- No hidden navigation - everything visible

### 4. Version Display
- Right-aligned in footer
- **Interactive**: Click for About or Update dialog
- **Red text** when update available (shows urgency)
- Subtle hover effect

### 5. Settings Access
- Integrated as fourth tab
- Same level as other main functions
- Direct navigation without extra clicks
- Consistent with main app flow

### 6. When Dashboard Appears
- User opens from system tray
- Critical error needs attention
- First launch after installation
- Manual app launch

## ğŸ”„ State Management

```typescript
interface DashboardState {
  // Active processes (only one at a time)
  activeProcess: {
    id: string;
    type: 'import' | 'export' | null;
    source: string;  // e.g., "Topcon MYAH", "AL550"
    progress?: {
      current: number;
      total: number;
      unit: string;  // "files" or "patients"
    };
    startedAt: DateTime;
  } | null;

  // Recent completed activities
  recentActivity: ActivityItem[];

  // Filter state
  filter: 'all' | 'import' | 'export' | 'errors';

  // Activity counts
  counts: {
    total: number;
    imports: number;
    exports: number;
    errors: number;
  };

  // Version info
  version: {
    current: string;
    updateAvailable?: string;
    updateCheckedAt: DateTime;
  };
}

interface ActivityItem {
  id: string;
  timestamp: DateTime;
  type: 'import' | 'export' | 'error';
  status: 'success' | 'warning' | 'error';
  source: string;  // Device/adapter name
  details: string; // What happened
  items?: string[]; // Filenames or patient names
  count?: number;  // Number of items processed
  error?: string;  // Error details for warnings/errors
}
```

### Process Completion Flow

```typescript
// When a process completes:
function onProcessComplete(process: ActiveProcess) {
  // 1. Remove from active
  state.activeProcess = null;

  // 2. Create completed activity with timestamp
  const completedActivity: ActivityItem = {
    ...process,
    timestamp: DateTime.now(),
    status: 'success'
  };

  // 3. Add to top of recent activities
  state.recentActivity.unshift(completedActivity);

  // 4. Trim to keep only last 50 activities
  state.recentActivity = state.recentActivity.slice(0, 50);
}
```

## Responsive Behavior

- **< 1280px**: Cards stack vertically
- **< 1200px**: Activity statistics hidden
- **< 1100px**: Tab text shortened ("Import & Export" â†’ "Import")
- **< 1024px**: Simplified activity items
- **< 768px**: Icon-only navigation with tooltips
- **Always**: Minimum 1024px recommended

## Performance

- Shows all of today's activities (no fixed limit)
- Auto-scrolls if needed (with subtle scrollbar)
- Updates every 2 seconds when visible
- Pauses updates when minimized
- Smooth transitions when activities complete

## User Flow

### Activity Timeline Flow

```
System starts process
  â”‚
  â”œâ”€â†’ Active Process card appears (pinned)
  â”‚     â”‚
  â”‚     â”œâ”€â†’ Shows "[NOW]" timestamp
  â”‚     â”œâ”€â†’ Animated icon (subtle pulse)
  â”‚     â”œâ”€â†’ Live progress updates
  â”‚     â””â”€â†’ Progress dots animation
  â”‚
  â”œâ”€â†’ Process completes
  â”‚     â”‚
  â”‚     â”œâ”€â†’ Card transitions to regular activity
  â”‚     â”œâ”€â†’ Gets real timestamp
  â”‚     â””â”€â†’ Moves into timeline
  â”‚
  â””â”€â†’ Timeline updates
        â”‚
        â”œâ”€â†’ New activity at top
        â”œâ”€â†’ Others shift down
        â””â”€â†’ Oldest falls off (>50)
```

### Navigation Flow

```
Dashboard Tab (Active)
  â”‚
  â”œâ”€â†’ User clicks "Import & Export"
  â”‚     â””â”€â†’ Navigate to Import & Export screen
  â”‚
  â”œâ”€â†’ User clicks "History"
  â”‚     â””â”€â†’ Navigate to full History
  â”‚
  â””â”€â†’ User clicks "Settings"
        â””â”€â†’ Navigate to Settings screen
```

**Key Principle**: DATEYE runs silently in the system tray. The UI is only opened when needed.

## Success Metrics

- Time to understand system state: < 2 seconds
- Minimal resource usage when open
- Clear indication when action needed
- Easy return to system tray



FILE: ui-design/connections/connections.md
==================================================

# Connections Screen

Import/Export workflow management interface for medical device integration.

## Concept

**ImportAdapter/ExportAdapter Architecture:** DATEYE uses separate adapter interfaces for medical device integration. Users configure import sources and export targets independently, then create logical connections between them.

**Example Workflows:**
- MYAH files â†’ DATEYE (ImportAdapter for file processing)
- DATEYE â†’ AL550 device (ExportAdapter for patient registration)
- Eye-Office API â†’ DATEYE (ImportAdapter for practice management sync)
- DATEYE â†’ File backup (ExportAdapter for data archiving)

## Layout Structure

### Main View - Active Connections

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                           [_] [â–¡] [x]   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ [LOGO] Dashboard â”‚ Connections â”‚ History â”‚ Settings     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                          â”‚
â”‚  Import & Export Connections           [New Connection] â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚                                                          â”‚
â”‚  Active Import Sources                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ ğŸ“ MYAH Files â†’ DATEYE                     âœ“   â”‚   â”‚
â”‚  â”‚   Watch folder: C:\Import\MYAH                 â”‚   â”‚
â”‚  â”‚   Status: 3 files imported today               â”‚   â”‚
â”‚  â”‚   [Configure] [Pause]                          â”‚   â”‚
â”‚  â”‚                                                 â”‚   â”‚
â”‚  â”‚ ğŸ”— Eye-Office API â†’ DATEYE                â¸   â”‚   â”‚
â”‚  â”‚   Sync every 5 minutes                         â”‚   â”‚
â”‚  â”‚   Status: Paused (API maintenance)             â”‚   â”‚
â”‚  â”‚   [Configure] [Resume]                          â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                          â”‚
â”‚  Active Export Targets                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ DATEYE â†’ ğŸ“Ÿ AL550 Device               âœ“   â”‚   â”‚
â”‚  â”‚   Patient registration enabled                  â”‚   â”‚
â”‚  â”‚   Status: 2 patients exported 1 hour ago       â”‚   â”‚
â”‚  â”‚   [Configure] [Test Connection]                 â”‚   â”‚
â”‚  â”‚                                                 â”‚   â”‚
â”‚  â”‚ DATEYE â†’ ğŸ’¾ File Backup                   âœ“   â”‚   â”‚
â”‚  â”‚   Daily backup to external drive               â”‚   â”‚
â”‚  â”‚   Status: Last backup completed 6 hours ago    â”‚   â”‚
â”‚  â”‚   [Configure] [Run Now]                         â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                          â”‚
â”‚  Manual Operations                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ [Import Files] [Export Data] [Batch Processing] â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Empty State - No Connections

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  No import sources or export targets configured         â”‚
â”‚                                                          â”‚
â”‚  Set up data workflows between your medical devices.    â”‚
â”‚  Configure import sources and export targets separately.â”‚
â”‚                                                          â”‚
â”‚  Examples:                                               â”‚
â”‚  â€¢ Import: MYAH Files â†’ DATEYE (File monitoring)       â”‚
â”‚  â€¢ Export: DATEYE â†’ AL550 Device (Patient registration)â”‚
â”‚  â€¢ Import: Eye-Office API â†’ DATEYE (Scheduled sync)    â”‚
â”‚                                                          â”‚
â”‚                    [New Connection]                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## New Connection Dialog

### Import Source Configuration

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Configure Import Source                                           [X] â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                       â”‚
â”‚  Select Import Adapter:                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚
â”‚  â”‚ â—‰ ğŸ“ MYAH Files                                 â”‚                 â”‚
â”‚  â”‚   Import XML files from Topcon MYAH device     â”‚                 â”‚
â”‚  â”‚   Source: File system monitoring               â”‚                 â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
â”‚                                                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚
â”‚  â”‚ â—‹ ğŸ”— Eye-Office API                             â”‚                 â”‚
â”‚  â”‚   Import patient data via REST API             â”‚                 â”‚
â”‚  â”‚   Source: Practice management system           â”‚                 â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
â”‚                                                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚
â”‚  â”‚ â—‹ ğŸ“‚ Manual File Import                         â”‚                 â”‚
â”‚  â”‚   One-time file import                         â”‚                 â”‚
â”‚  â”‚   Source: User file selection                  â”‚                 â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
â”‚                                                                       â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚                                                                       â”‚
â”‚  ğŸ“ MYAH Files Configuration                                         â”‚
â”‚                                                                       â”‚
â”‚  Watch Folder: [C:\Import\MYAH\           ] [Browse]                 â”‚
â”‚  File Pattern: [*.xml                     ]                          â”‚
â”‚  Processing:   â˜‘ Delete files after import                          â”‚
â”‚                â˜‘ Create backup copies                               â”‚
â”‚                                                                       â”‚
â”‚                                   [Test] [Save Import Source]        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Export Target Configuration

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Configure Export Target                                           [X] â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                       â”‚
â”‚  Select Export Adapter:                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚
â”‚  â”‚ â—‰ ğŸ“Ÿ AL550 Device                               â”‚                 â”‚
â”‚  â”‚   Export patient data to optical biometer      â”‚                 â”‚
â”‚  â”‚   Target: HTTP API (192.168.1.100)            â”‚                 â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
â”‚                                                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚
â”‚  â”‚ â—‹ ğŸ’¾ File Export                                â”‚                 â”‚
â”‚  â”‚   Export data to JSON/CSV files               â”‚                 â”‚
â”‚  â”‚   Target: File system                          â”‚                 â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
â”‚                                                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚
â”‚  â”‚ â—‹ â˜ï¸ Myopia.cloud                               â”‚                 â”‚
â”‚  â”‚   Export anonymized data for analytics         â”‚                 â”‚
â”‚  â”‚   Target: Cloud platform                       â”‚                 â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
â”‚                                                                       â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚                                                                       â”‚
â”‚  ğŸ“Ÿ AL550 Device Configuration                                       â”‚
â”‚                                                                       â”‚
â”‚  Device IP:    [192.168.1.100        ]                              â”‚
â”‚  Port:         [8080                 ]                              â”‚
â”‚  Export Mode:  â—‰ Auto-export  â—‹ Manual only                         â”‚
â”‚  Data Filter:  â˜‘ New patients only                                  â”‚
â”‚                â˜‘ Include patient demographics                       â”‚
â”‚                                                                       â”‚
â”‚                                   [Test] [Save Export Target]        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Key Simplifications

**Separate Configuration:**
- **Import Sources** configured independently
- **Export Targets** configured independently
- **Logical Connections** created through workflow management

**Adapter-Specific Forms:**
- Each ImportAdapter has custom configuration UI
- Each ExportAdapter has custom configuration UI
- Type-safe validation in adapter implementations

**Clear Data Flow:**
- Import: Device/API â†’ DATEYE
- Export: DATEYE â†’ Device/File/Cloud
- Manual operations available for one-time tasks

## Available Import Adapters

### File-Based Import

| Adapter | Configuration | Data Source |
|---------|---------------|-------------|
| **MYAH Files** | Watch folder, file patterns | XML files from Topcon MYAH |
| **IOLMaster Files** | DICOM folder monitoring | DICOM files from ZEISS devices |
| **Manual Import** | File browser | User-selected files |

### API-Based Import

| Adapter | Configuration | Data Source |
|---------|---------------|-------------|
| **Eye-Office API** | REST endpoint, credentials | Practice management system |
| **Cloud Import** | API credentials, sync schedule | Cloud platforms |

## Available Export Adapters

### Device Export

| Adapter | Configuration | Target |
|---------|---------------|--------|
| **AL550 Device** | IP address, patient filter | HTTP API for patient registration |
| **Eye-Office Export** | API credentials | Practice management system |

### File/Cloud Export

| Adapter | Configuration | Target |
|---------|---------------|--------|
| **File Export** | Output folder, format (JSON/CSV) | Local file system |
| **Myopia.cloud** | API credentials, anonymization | Cloud analytics platform |

## Connection Management

### Import Source States

```typescript
enum ImportSourceStatus {
  active,      // Monitoring and processing files/API
  paused,      // User-paused
  error,       // Connection/processing error
  disabled,    // User-disabled
}
```

### Export Target States

```typescript
enum ExportTargetStatus {
  active,      // Ready to receive exports
  testing,     // Connection test in progress
  error,       // Connection/export error
  disabled,    // User-disabled
}
```

### Status Indicators

- ğŸŸ¢ **Active**: Processing data successfully
- ğŸŸ¡ **Warning**: Minor issues, auto-retrying
- ğŸ”´ **Error**: Manual intervention required
- â¸ï¸ **Paused**: User-paused or scheduled downtime

### Connection Actions

```
[Configure] - Modify adapter configuration
[Test] - Validate connection/configuration
[Pause/Resume] - Toggle active state
[View Data] - Browse imported/exported data
[Delete] - Remove import source or export target
```

## State Management

```typescript
interface ConnectionsState {
  // Import sources
  importSources: ImportSource[];

  // Export targets
  exportTargets: ExportTarget[];

  // Manual operations
  isImporting: boolean;
  isExporting: boolean;

  // Discovery
  availableAdapters: AdapterInfo[];
}

interface ImportSource {
  id: string;
  adapterId: string;           // 'topcon_myah', 'eye_office_api'
  name: string;                // User-friendly name
  config: Map<string, dynamic>; // Adapter-specific configuration
  status: ImportSourceStatus;
  lastImport?: DateTime;
  statistics: ImportStatistics;
}

interface ExportTarget {
  id: string;
  adapterId: string;           // 'al550_export', 'file_export'
  name: string;                // User-friendly name
  config: Map<string, dynamic>; // Adapter-specific configuration
  status: ExportTargetStatus;
  lastExport?: DateTime;
  statistics: ExportStatistics;
}
```

## Error Handling & Recovery

### Import Errors

**File Processing Issues:**
```
ğŸ”´ MYAH Import Error
   Failed to parse patient_001.xml (Invalid XML format)

   [Skip File] [Retry] [View Details]
```

**API Connection Issues:**
```
ğŸ”´ Eye-Office API Error
   Connection timeout (https://eye-office.local:4450)

   [Test Connection] [Edit Configuration] [Retry]
```

### Export Errors

**Device Offline:**
```
ğŸ”´ AL550 Export Error
   Device unreachable (192.168.1.100:8080)

   [Test Connection] [Edit Configuration] [Queue for Retry]
```

**Data Validation:**
```
ğŸŸ¡ Export Warning
   2 patients skipped (missing required fields)
   8 patients exported successfully

   [View Details] [Export Failed Items] [Continue]
```

## Responsive Behavior

- **< 1400px**: Hide detailed statistics
- **< 1200px**: Stack import/export sections vertically
- **< 1024px**: Simplified connection cards
- **< 768px**: Mobile-optimized layout with tabs

## Performance Optimization

### Import Processing
- Stream processing for large files
- Parallel processing for multiple sources
- Progress indicators for long imports

### Export Operations
- Batch operations for multiple patients
- Retry mechanisms with exponential backoff
- Progress tracking for network operations

## Future Enhancements

### Advanced Import Features
```
Conditional import: "Only new patients since last sync"
Data transformation: Custom field mapping
Multi-format support: DICOM, HL7, CSV
```

### Advanced Export Features
```
Scheduled exports: "Daily backup at 2 AM"
Conditional exports: "Only patients with recent exams"
Multi-target exports: Send to multiple destinations
```

## Success Metrics

- Import configuration time: < 3 minutes for file sources
- Export setup time: < 5 minutes for network devices
- Error recovery rate: > 85% automatic resolution
- Data processing reliability: > 99% success rate

## Related Documentation

- [ImportAdapter Development](../adapter-development.md) - Implementing import adapters
- [ExportAdapter Development](../adapter-development.md) - Implementing export adapters
- [Dashboard](../dashboard/dashboard.md) - Import/export status overview
- [History](../history/history.md) - Complete operation logs



FILE: ui-design/history/history.md
==================================================

# History Screen

Complete record of all DATEYE operations and system activities.

## Purpose

The History screen provides comprehensive visibility into all system activities, not just today's events. It serves as the central location for troubleshooting, auditing, and manual export selection.

## Layout Structure

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                           [_] [â–¡] [x]   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ [LOGO] Dashboard â”‚ Connections â”‚ History â”‚ Settings â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                          â”‚
â”‚  All Activities                       [Export Selected]  â”‚
â”‚                                                          â”‚
â”‚  [â–¼ Last 7 days    ] [â–¼ All Types  ] [Search...     ]  â”‚
â”‚                                                          â”‚
â”‚  â”Œâ”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚â˜â”‚ [2024-07-11 14:32] âœ“ Transfer: MYAH â†’ AL550      â”‚ â”‚
â”‚  â”‚ â”‚ Schmidt_Anna_2024.xml - 3 measurements            â”‚ â”‚
â”‚  â”‚ â”‚ Patient: Anna Schmidt (2010-03-15)               â”‚ â”‚
â”‚  â”œâ”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚  â”‚â˜â”‚ [2024-07-11 14:28] âœ“ Transfer: Eye-Office â†’ USB  â”‚ â”‚
â”‚  â”‚ â”‚ Anna Schmidt, Hans Mueller - Auto Transfer       â”‚ â”‚
â”‚  â”‚ â”‚ Target: Backup Drive - Success                   â”‚ â”‚
â”‚  â”œâ”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚  â”‚â˜â”‚ [2024-07-11 14:15] âš  Transfer: AL550 â†’ Cloud     â”‚ â”‚
â”‚  â”‚ â”‚ Connection timeout - Retry 1/3                    â”‚ â”‚
â”‚  â”‚ â”‚ Next retry: 14:45                                â”‚ â”‚
â”‚  â”œâ”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚  â”‚â˜â”‚ [2024-07-11 14:10] âœ“ Sync: Eye-Office API        â”‚ â”‚
â”‚  â”‚ â”‚ 15 patients synchronized - Auto Sync             â”‚ â”‚
â”‚  â”‚ â”‚ Duration: 2.3 seconds                            â”‚ â”‚
â”‚  â”œâ”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚  â”‚â˜â”‚ [2024-07-11 13:58] âœ“ Transfer: IOLMaster â†’ Core  â”‚ â”‚
â”‚  â”‚ â”‚ bilateral_exam_2024.dcm - Manual Transfer        â”‚ â”‚
â”‚  â”‚ â”‚ Patient: Lisa Meyer (1955-08-22)                 â”‚ â”‚
â”‚  â””â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                          â”‚
â”‚  Showing 89 of 1,247 events               [Load More]   â”‚
â”‚                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Visual Design

### Activity Timeline
- **Workflow Activities**: Clear "Source â†’ Target" format for transfers
- **Regular Activities**: Clean white cards with hover effects
- **Enhanced Details**: Multi-line display with filenames, patient names
- **Visual Hierarchy**: Time â†’ Type â†’ Details â†’ Metadata
- **Monospace Timestamps**: Better alignment and technical feel

### Tab Navigation
- **Logo placement**: DATEYE logo on the left side of tabs
- **Four main tabs**: Dashboard, Connections, History, Settings
- **Active tab**: Pill-style background with light blue tint (#0087BA at 10% opacity)
- **Icons**: Each tab has an icon for better recognition
- **Responsive behavior**:
  - **Desktop (> 1100px)**: Full logo + icons with complete text
  - **Tablet (768-1100px)**: Smaller logo + icons with shortened text
  - **Mobile (< 768px)**: Text only (no logo, no icons), optimized for readability
- **Consistent padding**: 32px left/right at all screen sizes

### Smart Filtering
- Filter chips show counts: "All (22)", "Transfers (12)", etc.
- Numbers update dynamically as activities complete
- Quick visual indication of activity distribution
- Helps prioritize attention (e.g., "Errors (2)" draws eye)

## Core Functions

### 1. Complete History
- All events stored in `history.ndjson`
- Infinite scroll with lazy loading
- No data expiry (except manual archiving)
- Complete audit trail for compliance

### 2. Advanced Filtering
```
Time Ranges:
- Today
- Last 7 days
- Last 30 days
- Last 3 months
- Custom range
- All time

Activity Types:
- All Activities
- Workflow Transfers
- Manual Operations
- System Events
- Errors Only
- Scheduled Tasks
```

### 3. Activity Details
Each activity shows:
- **Primary Info**: Type, source, target, status
- **Secondary Info**: Affected files/patients
- **Metadata**: Duration, retry count, error details
- **Expandable**: Click for complete JSON view

### 4. Manual Export Selection
```
1. Select activities via checkboxes
2. Click "Export Selected"
3. Choose target device/folder
4. Confirm export
5. Track in export queue
```

### 5. Search Capabilities
- Patient names (decrypted on-the-fly)
- Filenames
- Device/adapter names
- Error messages
- Activity IDs

## State Management

```typescript
interface HistoryState {
  // Filter state
  timeRange: 'today' | '7days' | '30days' | '3months' | 'all';
  activityType: 'all' | 'transfer' | 'manual' | 'system' | 'error';
  searchQuery: string;

  // Activity data
  activities: ActivityEntry[];
  totalCount: number;
  hasMore: boolean;
  isLoading: boolean;

  // Selection state
  selectedActivityIds: Set<string>;

  // UI state
  expandedActivityIds: Set<string>;
  scrollPosition: number;
}

interface ActivityEntry {
  id: string;
  timestamp: DateTime;
  type: 'transfer' | 'import' | 'export' | 'sync' | 'system';
  mode: 'automatic' | 'manual' | 'scheduled';
  status: 'success' | 'warning' | 'error' | 'pending';

  // Workflow context
  workflow?: {
    source: string;  // "MYAH", "Eye-Office"
    target: string;  // "AL550", "Backup"
    name: string;    // "MYAH â†’ AL550"
  };

  // Legacy support
  adapter?: string;
  file?: string;
  target?: string;

  // Common data
  patientData?: {
    name: string;  // Decrypted for display
    birthDate: string;
    externalId: string;
  };
  measurementCount?: number;
  duration?: number;  // milliseconds
  error?: string;
  retryCount?: number;
  nextRetry?: DateTime;
}
```

## Responsive Behavior

- **< 1400px**: Patient details hidden, shown on expand
- **< 1200px**: Compact timestamps (time only)
- **< 1024px**: Single-line activities with expand button
- **Always**: Checkbox column maintained for selection

## Performance

### Optimization Strategies
- Virtual scrolling for large lists
- Lazy decrypt of patient names
- Debounced search (300ms)
- Cached filter results
- Progressive loading (50 activities at once)

### Loading States
```
Initial Load:
- Show skeleton rows
- Load first 50 activities
- Enable interaction immediately

Scroll Loading:
- Show "Loading..." indicator
- Fetch next 50 activities
- Seamlessly append to list
```

## User Flows

### Troubleshooting Flow
```
Error in Dashboard
  â”‚
  â”œâ”€â†’ Click "History" tab
  â”‚
  â”œâ”€â†’ Filter: "Errors Only"
  â”‚
  â”œâ”€â†’ Find error activity
  â”‚     â”‚
  â”‚     â”œâ”€â†’ Click to expand
  â”‚     â”œâ”€â†’ Read error details
  â”‚     â””â”€â†’ Copy error for support
  â”‚
  â””â”€â†’ Take corrective action
```

### Manual Export Flow
```
History Tab
  â”‚
  â”œâ”€â†’ Search for patient
  â”‚
  â”œâ”€â†’ Select relevant activities
  â”‚     â”‚
  â”‚     â”œâ”€â†’ Check multiple boxes
  â”‚     â””â”€â†’ "Export Selected" enabled
  â”‚
  â”œâ”€â†’ Click "Export Selected"
  â”‚     â”‚
  â”‚     â”œâ”€â†’ Target selection dialog
  â”‚     â”œâ”€â†’ Choose device/folder
  â”‚     â””â”€â†’ Confirm export
  â”‚
  â””â”€â†’ Monitor in Dashboard
```

### Audit Review Flow
```
Compliance Request
  â”‚
  â”œâ”€â†’ History Tab
  â”‚
  â”œâ”€â†’ Set time range
  â”‚
  â”œâ”€â†’ Search patient name
  â”‚
  â””â”€â†’ Export matching activities
        â”‚
        â”œâ”€â†’ Select all results
        â”œâ”€â†’ Export as JSON/CSV
        â””â”€â†’ Save for records
```

## Security Considerations

### Patient Name Display
- Names decrypted on-demand from `identity.enc`
- Never stored in UI state
- Cleared from memory after display
- Search operates on encrypted IDs first

### Activity Selection
- Maximum 100 activities selectable at once
- Confirmation required for bulk operations
- Export creates new log entries
- Original activities never modified

## Keyboard Shortcuts

- `Ctrl/Cmd + F`: Focus search field
- `Space`: Toggle selection on focused row
- `Ctrl/Cmd + A`: Select all visible
- `Escape`: Clear selection
- `Enter`: Expand/collapse focused activity

## Localization

All UI text localized:
- Time format respects system locale
- Status messages translated
- Error descriptions in user language
- Technical IDs remain English

## Success Metrics

- Find specific activity: < 5 seconds
- Export selected activities: < 3 clicks
- Browse through 1000 activities: < 100ms per page
- Search response time: < 300ms

## Related Documentation

- [Dashboard](../dashboard/dashboard.md) - Shows today's summary
- [Import & Export](../import-export/import-export.md) - Configure operations
- [Data Formats](../../data-formats.md) - Log file structure



FILE: ui-design/settings/settings.md
==================================================

# Settings Screen

Simple configuration for DATEYE's runtime behavior.

## Purpose

The Settings screen provides essential configuration options for DATEYE. Following the philosophy of simplicity, it contains only necessary settings. Import/Export configuration has dedicated screens accessible from here.

## Layout Structure

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                           [_] [â–¡] [x]   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ [LOGO] Dashboard â”‚ Connections â”‚ History â”‚ Settings â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                          â”‚
â”‚  General Settings                                        â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚                                                          â”‚
â”‚  Language                                                â”‚
â”‚  [â–¼ English              ]                               â”‚
â”‚     German                                               â”‚
â”‚                                                          â”‚
â”‚  Startup                                                 â”‚
â”‚  â˜‘ Start with system                                    â”‚
â”‚  â˜‘ Start minimized to tray                              â”‚
â”‚                                                          â”‚
â”‚  Data Management                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚   Import Settings   â”‚  â”‚   Export Settings   â”‚      â”‚
â”‚  â”‚   Configure folders â”‚  â”‚   Manage targets    â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                                                          â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚                                                          â”‚
â”‚  About DATEYE                                            â”‚
â”‚  Version 1.0.0                                           â”‚
â”‚  Â© 2024 DATEYE Â· MIT License                            â”‚
â”‚                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Visual Design

### Layout Principles
- Single column, no sidebar needed
- Clear sections with horizontal dividers
- Immediate saving (no Save/Cancel buttons)
- Cards for navigation to sub-settings

### Visual Elements
- **Dropdown**: Standard system dropdown for language
- **Checkboxes**: Simple toggles for startup options
- **Cards**: Clickable areas for import/export settings
- **About**: Subtle footer area

## Settings Structure

### General Settings

#### Language Selection
```
- English (Default)
- German
- System Default (future)
```
Changes apply immediately throughout the UI.

#### Startup Options
```
â˜‘ Start with system
  - Adds DATEYE to OS startup
  - Platform-specific implementation

â˜‘ Start minimized to tray
  - Opens directly in system tray
  - No window shown at startup
```

#### Data Management Links
Two cards that navigate to dedicated screens:
- **Import Settings**: Configure watch folders and adapters
- **Export Settings**: Manage export targets and devices

### About Section
```
Version: 1.0.0
License: MIT License
Copyright: Â© 2024 DATEYE
```

## Core Functions

### 1. Auto-Save
- All changes saved immediately
- No Save/Cancel workflow
- Visual feedback on change (subtle animation)

### 2. Live Updates
- Language change immediate
- No restart required
- File watcher detects external changes

### 3. Platform-Aware
- Startup options adapt to OS
- Correct terminology per platform
- Native system integration

## State Management

```typescript
interface SettingsState {
  // Core settings
  language: 'en' | 'de' | 'system';
  startWithSystem: boolean;
  startMinimized: boolean;

  // Runtime state
  isLoading: boolean;
  lastSaved: DateTime;
}

// Separate state for sub-screens
interface ImportSettingsState { ... }
interface ExportSettingsState { ... }
```

## Storage

Settings are stored as JSON in platform-specific locations:

**File**: `settings.json`

**Locations**:
- Windows: `%APPDATA%/DATEYE/settings.json`
- macOS: `~/Library/Application Support/DATEYE/settings.json`
- Linux: `~/.config/DATEYE/settings.json`

**Format**:
```json
{
  "language": "en",
  "startup": {
    "autostart": true,
    "minimizeOnLaunch": true
  },
  "version": "1.0.0"
}
```

## Future Extensions (v2+)

If actually needed:
- Notification settings
- Theme selection (if requested)
- Advanced/Debug settings:
  - Log level (Info/Debug/Verbose)
  - Performance options
  - Cache management
- Backup/Restore settings
- Cloud sync settings

## Keyboard Navigation

- `Tab`: Navigate between controls
- `Space`: Toggle checkboxes
- `Enter`: Activate cards/buttons
- `â†‘â†“`: Navigate dropdown options

## Localization

All text uses the app's i18n system:
- Immediate language switching
- No hardcoded strings
- Fallback to English if keys missing

## Responsive Behavior

- Minimum width: 600px
- Maximum width: 800px (centered)
- Scales appropriately on larger screens

## Testing Considerations

1. **Language switching**: Verify all UI updates
2. **Startup registration**: Test per platform
3. **File watching**: External changes should reflect
4. **Navigation**: Cards should route correctly
5. **Auto-save**: Changes persist immediately

## Related Screens

- [Import & Export](../import-export/import-export.md) - Detailed data management
- [Dashboard](../dashboard/dashboard.md) - Return to main view



FILE: ui-design/eye-office-setup/eye-office-setup.md
==================================================

# Eye-Office API Setup

Step-by-step guide for setting up Eye-Office REST API integration.

## Purpose

This guide walks through setting up the Eye-Office API connection, including CRM criteria configuration and initial synchronization.

## Prerequisites

### In Eye-Office Administration
1. **CRM Criterion "Export"**
   - Navigation: Administration â†’ CRM Criteria
   - Create new criterion named "Export" (capital E)
   - Choose distinctive color (e.g., green #00FF00)
   - Save changes

2. **Mark patients for export**
   - Open each patient record to be synchronized
   - Check "Export" in the CRM criteria section
   - Save patient

### From Eye-Office Support
- API key for your installation
- API endpoint URL (typically port 4450)

## Setup Flow

### 1. Initial Connection

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Eye-Office API Setup                          Step 1/3   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                          â”‚
â”‚  Connect DATEYE to your Eye-Office installation         â”‚
â”‚                                                          â”‚
â”‚  Server URL                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ https://eye-office.local               :4450    â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚  Example: https://eye-office.local:4450                 â”‚
â”‚                                                          â”‚
â”‚  API Key                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—        [Show]    â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚  Get this from Eye-Office support                       â”‚
â”‚                                                          â”‚
â”‚  Eye-Office Username                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ dr.schmidt                                      â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                          â”‚
â”‚  Eye-Office Password                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ â—â—â—â—â—â—â—â—â—â—â—â—                         [Show]    â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚  Use your regular Eye-Office login                      â”‚
â”‚                                                          â”‚
â”‚             [Back] [Test Connection]                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. Connection Test & CRM Detection

#### Success Case
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Eye-Office API Setup                          Step 2/3   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                          â”‚
â”‚  Testing Connection...                                   â”‚
â”‚                                                          â”‚
â”‚  âœ… Server reachable                                     â”‚
â”‚  âœ… API key valid                                        â”‚
â”‚  âœ… Login successful                                     â”‚
â”‚  âœ… "Export" criterion found (ID: 789)                   â”‚
â”‚                                                          â”‚
â”‚  Connection successful!                                  â”‚
â”‚                                                          â”‚
â”‚                              [Continue]                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Missing CRM Criterion
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Eye-Office API Setup                          Step 2/3   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                          â”‚
â”‚  Testing Connection...                                   â”‚
â”‚                                                          â”‚
â”‚  âœ… Server reachable                                     â”‚
â”‚  âœ… API key valid                                        â”‚
â”‚  âœ… Login successful                                     â”‚
â”‚  âš ï¸  No "Export" CRM criterion found                     â”‚
â”‚                                                          â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚                                                          â”‚
â”‚  Please create it in Eye-Office:                        â”‚
â”‚  1. Open Eye-Office Administration                      â”‚
â”‚  2. Navigate to: CRM Criteria                           â”‚
â”‚  3. Create new criterion named "Export"                 â”‚
â”‚  4. Save and return here                                â”‚
â”‚                                                          â”‚
â”‚  [ğŸ“„ Print Instructions] [Retry] [Cancel]               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3. Configuration Complete

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Eye-Office API Setup                          Step 3/3   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                          â”‚
â”‚  âœ… Setup Complete!                                      â”‚
â”‚                                                          â”‚
â”‚  Connection Details:                                     â”‚
â”‚  â€¢ Server: eye-office.local                             â”‚
â”‚  â€¢ User: dr.schmidt                                     â”‚
â”‚  â€¢ Export criterion ID: 789                             â”‚
â”‚                                                          â”‚
â”‚  Sync Settings:                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ â˜‘ Enable automatic sync                         â”‚   â”‚
â”‚  â”‚                                                 â”‚   â”‚
â”‚  â”‚ Sync interval:  [â–¼ Every 5 minutes    ]        â”‚   â”‚
â”‚  â”‚                                                 â”‚   â”‚
â”‚  â”‚ â˜‘ Import visual acuity (visusCc)               â”‚   â”‚
â”‚  â”‚ â˜‘ Import prism values                          â”‚   â”‚
â”‚  â”‚ â˜‘ Import objective refraction                  â”‚   â”‚
â”‚  â”‚ â˜‘ Import subjective refraction                 â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                          â”‚
â”‚  Found 47 patients marked with "Export"                 â”‚
â”‚                                                          â”‚
â”‚                              [Start Initial Sync]        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Import & Export Screen Integration

### New Tab for Eye-Office API

Eye-Office appears as an option in both manual and automatic import:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ â† Dashboard    Import & Export                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚ Import              â”‚ Export                â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚                                                          â”‚
â”‚  Automatic Sync Sources                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ Eye-Office API      eye-office.local         âœ“ â”‚   â”‚
â”‚  â”‚    Every 5 minutes â€¢ Export tag filter         â”‚   â”‚
â”‚  â”‚    Last: 47 patients synced 2 min ago         â”‚   â”‚
â”‚  â”‚                                                 â”‚   â”‚
â”‚  â”‚                    [+ Add Sync Source]          â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                          â”‚
â”‚  Watch Folders                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ Topcon MYAH         C:\Import\MYAH           âœ“ â”‚   â”‚
â”‚  â”‚    Topcon MYAH â€¢ Keep files                    â”‚   â”‚
â”‚  â”‚    Last: 1 file imported 1 hour ago           â”‚   â”‚
â”‚  â”‚                                                 â”‚   â”‚
â”‚  â”‚ AL550               D:\AL550\Export          â¸ â”‚   â”‚
â”‚  â”‚    Mediworks AL550 â€¢ Disabled                  â”‚   â”‚
â”‚  â”‚    Last: No imports yet                       â”‚   â”‚
â”‚  â”‚                                                 â”‚   â”‚
â”‚  â”‚                        [+ Add Watch Folder]     â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                          â”‚
â”‚  Recent Imports                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ âœ… 14:32 - Anna Schmidt                         â”‚   â”‚
â”‚  â”‚    Updated: Refraction, Visual Acuity           â”‚   â”‚
â”‚  â”‚                                                 â”‚   â”‚
â”‚  â”‚ âœ… 14:28 - Max Weber                           â”‚   â”‚
â”‚  â”‚    New patient with 3 refractions               â”‚   â”‚
â”‚  â”‚                                                 â”‚   â”‚
â”‚  â”‚ âœ… 14:15 - Lisa Meyer                          â”‚   â”‚
â”‚  â”‚    Updated: Visual Acuity only                  â”‚   â”‚
â”‚  â”‚                                                 â”‚   â”‚
â”‚  â”‚ âš ï¸  14:10 - Import Warning                      â”‚   â”‚
â”‚  â”‚    3 patients missing "Export" tag              â”‚   â”‚
â”‚  â”‚    [View Details]                               â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Eye-Office Instructions Dialog

Accessible via [Configure] Button:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Eye-Office Configuration                            [X]  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                          â”‚
â”‚  Current Setup:                                          â”‚
â”‚  â€¢ Server: eye-office.local                             â”‚
â”‚  â€¢ Export criterion ID: 789                             â”‚
â”‚  â€¢ Sync interval: 5 minutes                             â”‚
â”‚                                                          â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚                                                          â”‚
â”‚  To export patients from Eye-Office:                    â”‚
â”‚                                                          â”‚
â”‚  1. In Eye-Office patient record:                       â”‚
â”‚     â€¢ Open CRM criteria section                         â”‚
â”‚     â€¢ Check "Export" checkbox                           â”‚
â”‚     â€¢ Save patient                                      â”‚
â”‚                                                          â”‚
â”‚  2. Only marked patients will sync to DATEYE            â”‚
â”‚                                                          â”‚
â”‚  3. Changes sync automatically every 5 minutes          â”‚
â”‚                                                          â”‚
â”‚  [ğŸ–¨ï¸ Print Instructions] [Change Settings] [Close]      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Missing Export Tag Warning

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Patients Without Export Tag                         [X]  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                          â”‚
â”‚  The following patients were updated in Eye-Office      â”‚
â”‚  but don't have the "Export" tag:                      â”‚
â”‚                                                          â”‚
â”‚  â€¢ Mueller, Hans (ID: 12345)                           â”‚
â”‚  â€¢ Fischer, Eva (ID: 12346)                            â”‚
â”‚  â€¢ Weber, Klaus (ID: 12347)                            â”‚
â”‚                                                          â”‚
â”‚  To include them in DATEYE:                            â”‚
â”‚  1. Open each patient in Eye-Office                    â”‚
â”‚  2. Add "Export" to CRM criteria                       â”‚
â”‚  3. Save patient                                        â”‚
â”‚  4. They'll sync on next interval                      â”‚
â”‚                                                          â”‚
â”‚                              [OK]                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## State Flow

### Setup States

```typescript
enum SetupState {
  Initial,        // Show connection form
  Testing,        // Test connection
  MissingCRM,     // Export criterion not found
  Ready,          // All checks passed
  Syncing         // Initial sync running
}
```

### Runtime States

```typescript
interface EyeOfficeApiState {
  connection: {
    status: 'connected' | 'disconnected' | 'error';
    lastPing: DateTime;
    sessionId?: string;
  };

  sync: {
    isRunning: boolean;
    lastSync: DateTime;
    nextSync: DateTime;
    patientCount: number;
    newCount: number;
  };

  config: {
    url: string;
    username: string;
    crmExportId: number;
    syncInterval: number;
    importOptions: {
      visualAcuity: boolean;
      prismValues: boolean;
      objectiveRefraction: boolean;
      subjectiveRefraction: boolean;
    };
  };
}
```

## Error Handling

### Connection Error

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Connection Error                                    [X]  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                          â”‚
â”‚  âŒ Could not connect to Eye-Office                      â”‚
â”‚                                                          â”‚
â”‚  Error: Connection timeout (eye-office.local:4450)      â”‚
â”‚                                                          â”‚
â”‚  Possible causes:                                        â”‚
â”‚  â€¢ Eye-Office server not running                        â”‚
â”‚  â€¢ Firewall blocking port 4450                          â”‚
â”‚  â€¢ Incorrect server URL                                 â”‚
â”‚  â€¢ Network connectivity issue                           â”‚
â”‚                                                          â”‚
â”‚  [Retry] [Edit Settings] [Cancel]                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Authentication Error

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Authentication Failed                               [X]  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                          â”‚
â”‚  âŒ Invalid credentials                                   â”‚
â”‚                                                          â”‚
â”‚  Please verify:                                          â”‚
â”‚  â€¢ Username is correct                                  â”‚
â”‚  â€¢ Password is current                                  â”‚
â”‚  â€¢ User has API access rights                           â”‚
â”‚  â€¢ Account is not locked                                â”‚
â”‚                                                          â”‚
â”‚  Contact Eye-Office administrator if needed             â”‚
â”‚                                                          â”‚
â”‚                    [Edit Credentials] [Cancel]           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Dashboard Integration

The main dashboard shows Eye-Office sync status:

```
Recent Activity
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[14:32] âœ“ API Import: 3 patients from Eye-Office
[14:28] âœ“ Export: 2 patients â†’ AL550
[14:15] âš  Eye-Office: 3 patients missing Export tag
```

## Security Considerations

1. **Credential Storage**
   - Username/password encrypted in `identity.enc`
   - API key encrypted with system key
   - Session ID only in memory

2. **Network Security**
   - HTTPS required for API connection
   - Certificate validation enabled
   - No credentials in logs

3. **Access Control**
   - Uses existing Eye-Office user permissions
   - Read-only access sufficient
   - No admin rights required

## Success Metrics

- Setup completion < 5 minutes
- No failed syncs due to configuration
- Clear error messages for troubleshooting
- Minimal Eye-Office admin intervention

## Related Documentation

- [Eye-Office Adapter](../../adapters/eye-office.md) - Technical Details
- [Import & Export](../import-export/import-export.md) - Main UI
- [Data Formats](../../data-formats.md) - JSON Structures



FILE: ui-design/eye-office-setup/eye-office-sync-details.md
==================================================

# Eye-Office Sync Details

Extended UI specifications for Eye-Office API synchronization dialogs.

## Sync Details Dialog

Dialog displayed when viewing Eye-Office API sync source details:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Eye-Office API Sync                                [X]  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                          â”‚
â”‚  Status: Connected                                       â”‚
â”‚  Server: eye-office.local:4450                          â”‚
â”‚  User: dr.schmidt                                       â”‚
â”‚                                                          â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚                                                          â”‚
â”‚  Sync Statistics:                                        â”‚
â”‚  â€¢ Last sync: 2 minutes ago (14:32)                    â”‚
â”‚  â€¢ Next sync: in 3 minutes                             â”‚
â”‚  â€¢ Sync interval: Every 5 minutes                      â”‚
â”‚                                                          â”‚
â”‚  â€¢ Total patients with "Export" tag: 47                â”‚
â”‚  â€¢ Synced today: 47 patients                           â”‚
â”‚  â€¢ New since last sync: 3                              â”‚
â”‚  â€¢ Updates since last sync: 12                         â”‚
â”‚                                                          â”‚
â”‚  Data Settings:                                          â”‚
â”‚  â˜‘ Visual acuity (visusCc)                             â”‚
â”‚  â˜‘ Prism values                                        â”‚
â”‚  â˜‘ Objective refraction                                â”‚
â”‚  â˜‘ Subjective refraction                               â”‚
â”‚                                                          â”‚
â”‚  [Sync Now] [Pause] [Configure] [View Log] [Close]     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Add Sync Source Dialog

Initial dialog for adding new automatic sync sources:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Add Automatic Sync Source                          [X]  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                          â”‚
â”‚  Source Type                                             â”‚
â”‚  â—‹ Eye-Office API                                       â”‚
â”‚  â—‹ Cloud Service (Future)                               â”‚
â”‚  â—‹ Network Device (Future)                              â”‚
â”‚                                                          â”‚
â”‚  [Continue] [Cancel]                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Dialog Actions

### Sync Details Dialog
- **Sync Now** - Triggers immediate synchronization
- **Pause** - Temporarily disables automatic sync
- **Configure** - Opens Eye-Office API setup wizard
- **View Log** - Opens filtered event log for Eye-Office sync events
- **Close** - Returns to Import & Export screen

### Add Sync Source Dialog
- **Continue** - Proceeds to selected source type setup
- **Cancel** - Returns to Import & Export screen

## State Management

### Sync Status States
- Connected - Active connection, successful sync
- Disconnected - Unable to reach server
- Paused - User-initiated sync pause
- Error - Authentication or other error

### Statistics Update
- Real-time update when dialog is open
- Cached values when closed
- Refresh on "Sync Now" action

## Related Documentation

- [Eye-Office Setup](eye-office-setup.md) - Main setup wizard
- [Import & Export](../import-export/import-export.md) - Parent screen
- [Eye-Office Adapter](../../adapters/eye-office.md) - Technical implementation



FILE: ui-design/identity-key-dialog/identity-key-dialog.md
==================================================

# Identity Key Dialog

First-time notification about the automatically generated identity key.

## Purpose

DATEYE uses a device-specific identity key for encrypting and decrypting sensitive patient data (`patients.enc`, `search.enc`). To ensure complete transparency and recovery options, the application shows this key the first time it is generated.

## Dialog Layout

```
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚      Your Identity Key Has Been Created                    â”‚
â”‚                                                            â”‚
â”‚  This key is required to decrypt encrypted patient        â”‚
â”‚  records.                                                  â”‚
â”‚                                                            â”‚
â”‚  Storage location:                                         â”‚
â”‚   C:\Users\%USER%\AppData\Local\DATEYE\identity.key       â”‚
â”‚                                                            â”‚
â”‚  For security, we recommend:                              â”‚
â”‚   â€¢ Making a backup copy of this file                     â”‚
â”‚   â€¢ Printing the key and storing it securely              â”‚
â”‚                                                            â”‚
â”‚  Identity Key:                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ 9c82-fdd1-7ae9-42b7-ae13-ff22b1a9129e             â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                            â”‚
â”‚  âš ï¸ IMPORTANT: Without this key, your data will be        â”‚
â”‚     permanently inaccessible!                              â”‚
â”‚                                                            â”‚
â”‚ [ Open Folder ]   [ Print ]                    [ OK ]     â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```

## Visual Design

The identity key dialog is a modal window that appears centered on screen with:

### Dialog Structure
- Clean white background with shadow
- Clear header with title
- Well-organized content sections
- Action buttons at the bottom

### Key Display
- Key displayed in highlighted box
- Monospace font for easy reading
- Blue background for attention
- Auto-select on click for easy copying

### Visual Hierarchy
1. **Title** - Clear statement of what happened
2. **Explanation** - Why this is important
3. **Storage location** - Where the key is stored
4. **Recommendations** - What to do next
5. **The key** - Most important element, visually prominent
6. **Warning** - Critical information highlighted
7. **Actions** - Clear next steps

### Warning Area
- Warning icon for attention
- Contrasting background
- Bold text for emphasis

## Core Functions

### 1. When it appears
- **First startup only** - after key generation
- Never appears again unless key is deleted
- Modal dialog - must be acknowledged

### 2. User Actions

| Button | Action |
|--------|--------|
| **Open Folder** | Opens file explorer to `identity.key` location |
| **Print** | Opens system print dialog with key info |
| **OK** | Closes dialog and continues to dashboard |

### 3. Key Properties
- Automatically generated (UUID v4)
- Stored as plain text file
- Not in system keychain (portable)
- Required for patient data decryption

## Security Considerations

### What the key protects
- `patients.enc` - Encrypted patient identities
- `search.enc` - Search index with names
- Separation of personal data from measurements

### Key Storage
- Local filesystem only
- User-specific app directory
- No cloud synchronization
- No automatic backup

### If the key is lost
- New key generated on next startup
- Previous encrypted data becomes inaccessible
- Measurements remain (anonymous)
- Patient assignment permanently lost

## Platform-Specific Paths

**Windows:**
```
C:\Users\%USERNAME%\AppData\Local\DATEYE\identity.key
```

**macOS:**
```
~/Library/Application Support/DATEYE/identity.key
```

**Linux:**
```
~/.config/DATEYE/identity.key
```

## Localization

All UI text uses the application's i18n system:
- Immediate language switching
- No hardcoded strings
- Fallback to English if keys are missing

Example translation keys:
```typescript
const translations = {
  title: "Your Identity Key Has Been Created",
  description: "This key is required to decrypt encrypted patient records.",
  recommendations: "For security, we recommend:",
  recommendationBackup: "Making a backup copy of this file",
  recommendationPrint: "Printing the key and storing it securely",
  warning: "IMPORTANT: Without this key, your data will be permanently inaccessible!",
  openFolder: "Open Folder",
  print: "Print",
  ok: "OK"
};
```

## Success Metrics

- User acknowledges dialog: 100%
- Backup action performed: > 80%
- Key recovery success rate: > 95%
- Support tickets for lost keys: < 5%



FILE: ui-design/logo/README.md
==================================================

# DATEYE Logo System

Complete logo system for the DATEYE medical device integration platform.

## File Structure

```
logo/
â”œâ”€â”€ README.md           # This file
â”œâ”€â”€ logo-showcase.html  # Visual preview of all logo variants
â”œâ”€â”€ dateye-main.svg     # Main logo (6642Ã—2800 ViewBox)
â”œâ”€â”€ dateye-icon.svg     # App icon (256Ã—256)
â”œâ”€â”€ dateye-tray.svg     # System tray icon (16Ã—16)
â”œâ”€â”€ dateye-loading.svg  # Animated logo for loading screens
â”œâ”€â”€ dateye-about.svg    # About dialog with tagline
â””â”€â”€ dateye-favicon.svg  # Browser favicon (32Ã—32)
```

## Logo Design

### Brand Identity
The DATEYE logo consists of two typographic elements:
- **"DAT"**: Gray with 69% Opacity (`fill-opacity:0.69`)
- **"EYE"**: Light blue (`#0087ba`)

### Typography
- Geometric sans-serif font
- Bold stroke weight
- Tight letter spacing
- No gap between "DAT" and "EYE"

### Logo Construction
- ViewBox: 0 0 6642 2800 (aspect ratio 2.37:1)
- Transparent background
- Pure typography without container
- Scalable vector graphic

## Color Specification

```css
/* Primary colors */
--dateye-dat-gray: rgba(0, 0, 0, 0.69);  /* DAT text */
--dateye-eye-blue: #0087ba;              /* EYE text */

/* Semantic colors (from app) */
--dateye-primary: #0087ba;               /* Primary color */
--dateye-active: #16A34A;                /* Active/Success */
--dateye-export: #EA580C;                /* Export/Orange */
--dateye-error: #DC2626;                 /* Error */
```

## Usage Guidelines

### Minimum Clear Space
Minimum distance around the logo equals the height of the "E" letter.

### Minimum Sizes
- Main logo: 120px width
- App icon: 32Ã—32px (recommended: 256Ã—256px)
- System tray: 16Ã—16px (monochrome)
- Favicon: 16Ã—16px (recommended: 32Ã—32px)

### Background Compatibility
- Transparent - works on all backgrounds
- Optimal visibility on light to medium backgrounds
- On dark backgrounds: increase DAT opacity to 100%

### Prohibited Uses
- Do not change colors
- Do not distort proportions
- Do not add effects (shadows, gradients)
- Do not modify letter forms
- Do not place on backgrounds that impair readability

## Implementation

### HTML Integration
```html
<!-- Inline SVG with responsive size -->
<img src="logo/dateye-main.svg" alt="DATEYE Logo" style="width: 200px; height: auto;">

<!-- As favicon -->
<link rel="icon" type="image/svg+xml" href="logo/dateye-favicon.svg">
```

### Flutter Integration
```dart
// App icon
SvgPicture.asset(
  'assets/logo/dateye-main.svg',
  width: 200,
  fit: BoxFit.contain,
),

// System tray (monochrome variant)
SystemTray.setIcon('assets/logo/dateye-tray.svg'),
```

### CSS Integration
```css
.dateye-logo {
  background: url('dateye-main.svg') no-repeat center;
  background-size: contain;
  width: 200px;
  height: 84px; /* Maintain 2.37:1 aspect ratio */
}
```

## Logo Variants

### Main Logo (`dateye-main.svg`)
- **Usage**: Marketing, documentation, UI headers
- **Format**: Complete "DATEYE" text
- **Optimizations**: Fully readable from 120px width

### App Icon (`dateye-icon.svg`)
- **Usage**: Desktop icon, About dialogs
- **Format**: Square, simplified representation
- **Optimizations**: Recognizable from 32Ã—32px

### System Tray (`dateye-tray.svg`)
- **Usage**: Windows/macOS/Linux system tray
- **Format**: Monochrome, maximally simplified
- **Optimizations**: Readable at 16Ã—16px

### Favicon (`dateye-favicon.svg`)
- **Usage**: Browser tabs, bookmarks
- **Format**: High contrast for minimal sizes
- **Optimizations**: Recognizable at 16Ã—16px

### Loading Animation (`dateye-loading.svg`)
- **Usage**: Splash screens, loading states
- **Format**: Animated, 1.0 second duration
- **Animation**: "DAT" fade-in (0-0.8s), "EYE" slide-in (0.4-1.0s)

### About Dialog (`dateye-about.svg`)
- **Usage**: Info dialogs with tagline
- **Format**: Logo + "Medical Device Integration Platform"
- **Layout**: Vertically stacked or horizontal

## Adaptive Display

### Responsive Strategies

| Screen Width | Logo Variant | Implementation |
|--------------|--------------|----------------|
| > 1200px | Full logo + tagline | `dateye-about.svg` |
| 800-1200px | Full logo | `dateye-main.svg` |
| 400-800px | Compact logo | `dateye-icon.svg` |
| < 400px | Icon only | `dateye-favicon.svg` |

### Size Recommendations

| Context | Width | Height | File |
|---------|-------|--------|------|
| Header (Desktop) | 180-220px | auto | `dateye-main.svg` |
| Header (Tablet) | 140-180px | auto | `dateye-main.svg` |
| Header (Mobile) | 100-140px | auto | `dateye-main.svg` |
| App Icon | 64-256px | 64-256px | `dateye-icon.svg` |
| Favicon | 16-32px | 16-32px | `dateye-favicon.svg` |

## Technical Specifications

### SVG Optimization
All logo files are optimized for performance:
- Minimal SVG syntax
- No unnecessary groups or transformations
- Optimized path definitions
- Embedded font avoidance (outline paths)

### Color Space and Export
- Color space: sRGB
- Alpha transparency: Supported
- Vector format: Infinitely scalable
- Browser compatibility: All modern browsers

### Accessibility
- Sufficient contrast (WCAG AA compliant)
- Alternative text descriptions provided
- Scalable for visual impairments
- Monochrome fallback option available

## Quality Control

### Pre-Implementation Checklist
- [ ] Logo is readable at target size
- [ ] Colors match specifications
- [ ] Transparency works on all backgrounds
- [ ] SVG code is optimized and valid
- [ ] Alternative text is meaningful
- [ ] Browser tests performed

### Performance Criteria
- SVG file size < 5KB for main logo
- SVG file size < 2KB for icons
- Load time < 100ms on standard connection
- Render time < 16ms for 60fps animations

## License and Usage Rights

The DATEYE logo is copyrighted. Use only with express permission.

Â© 2024 DATEYE - All rights reserved.

## Technical Support

For questions about logo implementation or customization:
- Documentation: `/docs/ui-design/`
- Design System: `/docs/ui-design/design-system.md`
- Code Examples: `/repository/lib/presentation/widgets/`



FILE: adapters/topcon-myah.md
==================================================

# Topcon MYAH ImportAdapter

ImportAdapter for Topcon MYAH myopia control device.

## Overview

The MYAH ImportAdapter processes the following measurement data:
- Axial length (optical biometry)
- Keratometry and corneal topography
- Pupillometry
- Anterior chamber measurements
- Growth tracking data

## File Format

MYAH exports data as XML files:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<MYAH>
  <DeviceInfo>
    <Model>MYAH</Model>
    <Version>1.3.0</Version>
    <ExportDate>2024-03-15T14:30:00</ExportDate>
  </DeviceInfo>

  <Patient>
    <ID>1066587</ID>
    <FirstName>Anna</FirstName>
    <LastName>Schmidt</LastName>
    <BirthDate>2012-05-02</BirthDate>
    <Sex>Female</Sex>
  </Patient>

  <Measurement>
    <Eye>OD</Eye>
    <Date>2024-03-15</Date>
    <Time>14:25:30</Time>

    <AxialLength>24.52</AxialLength>
    <AxialLengthSNR>12.5</AxialLengthSNR>

    <FlatK>7.89</FlatK>
    <FlatAngle>178</FlatAngle>
    <SteepK>7.72</SteepK>
    <SteepAngle>88</SteepAngle>

    <HWTW>11.8</HWTW>
    <PupilDiameter>4.2</PupilDiameter>
    <ACD>3.21</ACD>
    <LT>3.65</LT>
    <CCT>542</CCT>
    <QualityScore>9</QualityScore>
  </Measurement>
</MYAH>
```

## Import Methods

### File-based Transfer
- Export from MYAH device to USB/network
- Configure source path in DATEYE

### Watch Folder
- Configure network path: `\\MYAH-PC\Exports\`
- Automatic transfer on file detection

## Field Mappings

### Patient Demographics

| MYAH | DATEYE | Notes |
|------|--------|-------|
| `Patient/ID` | `external_pid` | Prefixed with "MYAH-" |
| `Patient/FirstName` | `first_name` | |
| `Patient/LastName` | `last_name` | |
| `Patient/BirthDate` | `birth_date` | YYYY-MM-DD |
| `Patient/Sex` | `gender` | Male/Female â†’ male/female |

### Measurements

| MYAH | DATEYE | Unit | Description |
|------|--------|------|-------------|
| `AxialLength` | `axial_length.value` | mm | Eye length |
| `AxialLengthSNR` | `axial_length.snr` | - | Signal quality |
| `FlatK` | `cornea.k1_mm` | mm | Flat meridian |
| `SteepK` | `cornea.k2_mm` | mm | Steep meridian |
| `FlatAngle` | `cornea.axis_k1` | Â° | 0-180 |
| `SteepAngle` | `cornea.axis_k2` | Â° | 0-180 |
| `HWTW` | `white_to_white.horizontal` | mm | Corneal diameter |
| `PupilDiameter` | `pupil.photopic` | mm | Pupil size |
| `ACD` | `acd.value` | mm | Anterior chamber |
| `LT` | `lens_thickness.value` | mm | Lens thickness |
| `CCT` | `cornea.central_thickness` | Î¼m | Corneal thickness |

### Calculated Values

The adapter calculates keratometry in diopters:
```dart
// Standard keratometer index
const KERATOMETER_INDEX = 337.5;
k1_d = KERATOMETER_INDEX / k1_mm;
k2_d = KERATOMETER_INDEX / k2_mm;
astigmatism = abs(k2_d - k1_d);
```

## Quality Validation

### Signal Quality
- Minimum SNR: 5.0 for axial length
- Warning if SNR 2.0-5.0
- Reject if SNR < 2.0

### Range Validation

| Measurement | Normal | Warning | Reject |
|-------------|--------|---------|--------|
| Axial Length | 22-26mm | 20-30mm | <18 or >32mm |
| Keratometry | 40-48D | 38-50D | <35 or >55D |
| Pupil | 3-6mm | 2-8mm | <1.5 or >9mm |
| ACD | 2.5-4.0mm | 2.0-5.0mm | <1.5 or >5.5mm |

## Configuration

```json
{
  "adapters": {
    "topcon_myah": {
      "import_path": "/import/myah/",
      "delete_after_import": true,
      "quality": {
        "min_snr": 5.0,
        "min_quality_score": 7
      },
      "validation": {
        "require_both_eyes": false
      }
    }
  }
}
```

## Adapter Implementation

```dart
class TopconMyahAdapter extends DataAdapter {
  @override
  String get id => 'topcon_myah';

  @override
  Future<ParseResult?> parseFile(File file) async {
    if (!file.path.endsWith('.xml')) return null;

    final document = XmlDocument.parse(await file.readAsString());
    final root = document.rootElement;

    if (root.name.local != 'MYAH') return null;

    // Extract patient
    final patient = _parsePatient(root.findElements('Patient').first);

    // Extract measurements
    final measurements = <Measurement>[];

    for (final meas in root.findElements('Measurement')) {
      final eye = meas.findElements('Eye').first.text == 'OD' ? 'right' : 'left';
      final date = meas.findElements('Date').first.text;

      // Axial length
      measurements.add(Measurement('axial_length', {
        'eye': eye,
        'value': double.parse(meas.findElements('AxialLength').first.text),
        'snr': double.parse(meas.findElements('AxialLengthSNR').first.text),
        'measured_at': '${date}T${meas.findElements('Time').first.text}Z',
      }));

      // Keratometry
      final k1mm = double.parse(meas.findElements('FlatK').first.text);
      final k2mm = double.parse(meas.findElements('SteepK').first.text);

      measurements.add(Measurement('cornea', {
        'eye': eye,
        'k1_mm': k1mm,
        'k2_mm': k2mm,
        'k1_d': 337.5 / k1mm,
        'k2_d': 337.5 / k2mm,
        'axis_k1': int.parse(meas.findElements('FlatAngle').first.text),
        'axis_k2': int.parse(meas.findElements('SteepAngle').first.text),
        'astigmatism': (337.5 / k2mm - 337.5 / k1mm).abs(),
      }));
    }

    return ParseResult(
      externalPid: 'MYAH-${patient['id']}',
      patientData: patient,
      measurements: measurements,
      examDate: DateTime.parse(date),
    );
  }
}
```

## Error Handling

| Error | Handling |
|-------|----------|
| Invalid XML | Reject file, log error |
| Missing patient ID | Generate from name+birthdate |
| Out of range values | Import with warning flag |
| Low SNR (<5.0) | Import with quality warning |
| Very low SNR (<2.0) | Skip measurement |

## Unit Conversions

All keratometry values stored in both formats:
- Millimeters (device native)
- Diopters (calculated using 337.5 index)

## Character Encoding

- Files use UTF-8 encoding
- Handles special characters (Ã¤, Ã¶, Ã¼, ÃŸ)
- Patient names preserved exactly

## Limitations

The MYAH does not provide:
- Refraction data (requires separate device)
- Visual acuity measurements
- Subjective measurements
- OCT images (only numerical results)

## Testing

Test files in `test/fixtures/topcon-myah/`:
- `valid_export.xml` - Complete bilateral exam
- `single_eye.xml` - Only one eye measured
- `low_quality.xml` - Poor SNR values
- `german_chars.xml` - Special characters

## Troubleshooting

### Files Not Importing
- Check XML structure (must have `<MYAH>` root)
- Verify file permissions
- Check for XML syntax errors

### Missing Measurements
- Some values are optional (LT, CCT)
- Check device software version
- Verify export settings on device

## Related Documentation

- [Adapter Development](../adapter-development.md)
- [Data Formats](../data-formats.md)
- [Keratometry Conversion](../data-formats.md#unit-conversions)



FILE: adapters/zeiss-iolmaster.md
==================================================

# ZEISS IOLMaster ImportAdapter

ImportAdapter for ZEISS IOLMaster 500 and 700 optical biometers.

## Overview

The IOLMaster ImportAdapter supports both models:
- IOLMaster 500: Partial coherence interferometry biometer
- IOLMaster 700: Swept-source OCT biometer

Supported measurements:
- Axial length (optical)
- Keratometry (anterior cornea)
- Anterior chamber depth
- White-to-white distance

## IOLMaster 500

### File Format

Supports two export formats:

#### DICOM Format (Preferred)
- Standard DICOM biometry module
- Patient demographics in header
- Measurements in specific tags

#### XML Format (Legacy)
```xml
<IOLMaster500Export>
  <Patient>
    <ID>123456</ID>
    <FirstName>Hans</FirstName>
    <LastName>Mueller</LastName>
    <BirthDate>1950-03-15</BirthDate>
    <Sex>M</Sex>
  </Patient>
  <Examination Date="2024-01-15">
    <OD>
      <AxialLength>23.45</AxialLength>
      <SNR>12.8</SNR>
      <K1>43.25</K1>
      <K1Axis>178</K1Axis>
      <K2>44.50</K2>
      <K2Axis>88</K2Axis>
      <ACD>3.15</ACD>
      <WTW>11.9</WTW>
    </OD>
    <OS>
      <!-- Left eye data -->
    </OS>
  </Examination>
</IOLMaster500Export>
```

### DICOM Tags

| Tag | Field | DATEYE | Unit |
|-----|-------|--------|------|
| (0022,0030) | Axial Length | `axial_length.value` | mm |
| (0022,0031) | Keratometry | `cornea.k1_d`, `cornea.k2_d` | D |
| (0022,0032) | ACD | `acd.value` | mm |
| (0022,0033) | White-to-White | `white_to_white.horizontal` | mm |

### Quality Requirements

- Minimum SNR: 2.0
- Measurement count: â‰¥ 5
- Standard deviation: < 0.05mm

## IOLMaster 700

### Additional Capabilities

The 700 model provides:
- Swept-source OCT imaging
- Total keratometry (anterior + posterior)
- Lens thickness measurement
- Fixation check
- Reference images for toric IOLs

### DICOM Structure

Multiple instances per exam:
```
Study Instance UID
â”œâ”€â”€ Axial Measurements (1.2.840.10008.5.1.4.1.1.78.7)
â”œâ”€â”€ Keratometry (1.2.840.10008.5.1.4.1.1.78.3)
â”œâ”€â”€ IOL Calculations (1.2.840.10008.5.1.4.1.1.78.8)
â””â”€â”€ Reference Images (1.2.840.10008.5.1.4.1.1.77.1.5.1)
```

### Additional Measurements

| Measurement | DATEYE Field | Notes |
|-------------|--------------|-------|
| Central corneal thickness | `cornea.central_thickness` | From OCT |
| Lens thickness | `lens_thickness.value` | Direct measurement |
| Total keratometry | `cornea.type = "total"` | Licensed feature |
| Posterior K values | `cornea.posterior_k1_d` | If available |

## Configuration

```json
{
  "adapters": {
    "zeiss_iolmaster": {
      "import_path": "/import/iolmaster/",
      "formats": {
        "dicom": true,
        "xml": true
      },
      "quality": {
        "500": {
          "min_snr": 2.0,
          "min_measurements": 5
        },
        "700": {
          "min_snr": 8.0,
          "fixation_threshold": "fair"
        }
      }
    }
  }
}
```

## Adapter Implementation

```dart
class ZeissIOLMasterAdapter extends DataAdapter {
  @override
  String get id => 'zeiss_iolmaster';

  @override
  Future<ParseResult?> parseFile(File file) async {
    // Try DICOM first
    if (await _isDicomFile(file)) {
      return _parseDicom(file);
    }

    // Try XML
    if (file.path.endsWith('.xml')) {
      return _parseXml(file);
    }

    return null;
  }

  Future<ParseResult?> _parseDicom(File file) async {
    final dataset = await DicomParser.parse(file);

    // Check SOP Class
    final sopClass = dataset.getString(0x00080016);
    final isIOLMaster = sopClass?.contains('1.2.840.10008.5.1.4.1.1.78') ?? false;

    if (!isIOLMaster) return null;

    // Extract patient
    final patient = {
      'first_name': _parsePersonName(dataset.getString(0x00100010)),
      'last_name': _parsePersonName(dataset.getString(0x00100010), last: true),
      'birth_date': _parseDicomDate(dataset.getString(0x00100030)),
      'gender': _mapDicomSex(dataset.getString(0x00100040)),
    };

    // Extract measurements
    final measurements = <Measurement>[];

    // Axial length
    final axialLength = dataset.getFloat32(0x00220030);
    if (axialLength != null) {
      measurements.add(Measurement('axial_length', {
        'eye': _getEyeFromDataset(dataset),
        'value': axialLength,
        'method': 'optical',
      }));
    }

    // Keratometry
    final kSequence = dataset.getSequence(0x00220031);
    if (kSequence != null) {
      measurements.add(_parseKeratometry(kSequence));
    }

    return ParseResult(
      externalPid: 'iol_${dataset.getString(0x00100020)}',
      patientData: patient,
      measurements: measurements,
      examDate: DateTime.now(),
    );
  }
}
```

## Model Detection

The adapter automatically detects the model:

```dart
String _detectModel(Map data) {
  // IOLMaster 700 specific features
  if (data.containsKey('TotalKeratometry') ||
      data.containsKey('SweptSourceOCT')) {
    return 'iolmaster_700';
  }

  // Check software version
  final version = data['SoftwareVersion'];
  if (version?.startsWith('7.') ?? false) {
    return 'iolmaster_500';
  }

  return 'iolmaster_unknown';
}
```

## Error Handling

| Error | Handling |
|-------|----------|
| Invalid DICOM | Try XML parser |
| Missing patient ID | Use exam date + initials |
| Low SNR | Import with warning |
| Incomplete exam | Import available data |

## Range Validation

| Measurement | IOLMaster 500 | IOLMaster 700 |
|-------------|---------------|---------------|
| Axial Length | 20-30mm | 20-30mm |
| Keratometry | 37-52D | 38-52D |
| ACD | 2.0-5.0mm | 2.0-5.0mm |
| Lens Thickness | N/A | 3.0-6.0mm |

## Testing

Test files in `test/fixtures/zeiss-iolmaster/`:
- `iol500_dicom.dcm` - Standard DICOM export
- `iol500_xml.xml` - Legacy XML format
- `iol700_multiinstance.dcm` - Multiple DICOM files
- `iol700_total_k.dcm` - With total keratometry

## Limitations

### IOLMaster 500
- No lens thickness
- No posterior cornea
- Anterior keratometry only

### Both Models
- No refraction data
- No visual acuity
- No pupil measurements (photopic only)

## DICOM Specifics

### Character Encoding
```dart
String _parsePersonName(String? dicomName) {
  // DICOM format: Last^First^Middle
  final parts = dicomName?.split('^') ?? [];
  return parts.isNotEmpty ? parts[0] : '';
}
```

### Date Parsing
```dart
String _parseDicomDate(String? dicomDate) {
  // DICOM format: YYYYMMDD
  if (dicomDate?.length == 8) {
    return '${dicomDate!.substring(0,4)}-'
           '${dicomDate.substring(4,6)}-'
           '${dicomDate.substring(6,8)}';
  }
  return '';
}
```

## Related Documentation

- [Adapter Development](../adapter-development.md)
- [Data Formats](../data-formats.md)
- [ZEISS API Documentation](../external-apis/zeiss/README.md)



FILE: adapters/eye-office.md
==================================================

# Eye-Office ImportAdapter

ImportAdapter specification for Eye-Office practice management system integration.

## Overview

The Eye-Office ImportAdapter provides:
- Patient demographic data
- Current refraction values
- Historical prescription records
- Visual acuity measurements

Import methods:
1. **Manual Import**: One-time API synchronization
2. **Automatic Import**: Scheduled delta synchronization

## API Data Format

Eye-Office REST API response structure:

```json
{
  "id": 12345,
  "firstname": "Anna",
  "lastname": "Schmidt",
  "birthday": "2010-03-15",
  "sex": "female",
  "internalData": {
    "refraction": {
      "date": "2024-01-15",
      "refrRight": {
        "useForOrder": true,
        "sphere": -2.25,
        "cylinder": -0.50,
        "axisCylinder": 90,
        "addition": 0,
        "prismHorizontalValue": 0,
        "prismVerticalValue": 0,
        "backVertexDistance": 12,
        "visusSc": 0.5,
        "visusCc": 1.0
      },
      "refrLeft": {
        "useForOrder": true,
        "sphere": -2.00,
        "cylinder": -0.75,
        "axisCylinder": 85,
        "visusSc": 0.5,
        "visusCc": 1.0
      }
    }
  }
}
```

## Import Process Architecture

### Manual Import Process
1. **Trigger**: User-initiated action
2. **Source**: Full API query for tagged patients
3. **Scope**: Complete data snapshot
4. **Deduplication**: Patient ID based

### Automatic Import Process
1. **Trigger**: Scheduled interval (default: 5 minutes)
2. **Source**: Delta API query
3. **Scope**: Modified patients only
4. **Efficiency**: Incremental updates

Data extraction pipeline:
- **Patient Mapping**: Demographics to DATEYE format
- **Refraction Conversion**: Prescription data transformation
- **Measurement Extraction**: Separate measurement types

## Field Mapping Specification

### Patient Demographics

| Eye-Office Field | DATEYE Field | Data Type |
|-----------------|--------------|-----------|
| `firstname` | `first_name` | String (required) |
| `lastname` | `last_name` | String (required) |
| `birthday` | `birth_date` | Date (YYYY-MM-DD) |
| `sex` | `gender` | Enum (male/female/unknown) |
| `id` | `external_pid` | String (prefixed: "eo_") |

### Refraction Measurements

| Eye-Office Field | DATEYE Field | Unit | Description |
|-----------------|--------------|------|-------------|
| `sphere` | `sphere` | diopters | Spherical correction |
| `cylinder` | `cylinder` | diopters | Cylindrical correction |
| `axisCylinder` | `axis` | degrees | Cylinder axis (0-180) |
| `addition` | `addition` | diopters | Near addition |
| `backVertexDistance` | `vertex` | mm | Vertex distance |
| `useForOrder` | `use_for_order` | boolean | Current prescription |

### Prism Values

Prism components stored separately:

```dart
// Horizontal prism conversion
if (prismHorizontalValue > 0) {
  prism.add({
    'value': prismHorizontalValue,
    'base': prismHorizontalAxis  // TABO notation
  });
}
```

### Visual Acuity

Converted to separate measurement type:

```json
{
  "type": "visual_acuity",
  "data": {
    "eye": "right",
    "value": 1.0,        // Decimal notation
    "correction": "cc"    // Corrected only
  }
}
```

### Complete Prism Mapping

| Eye-Office Field | DATEYE Field | Unit | Description |
|-----------------|--------------|------|-------------|
| `prismHorizontalValue` | `prism.horizontal.value` | prism diopters | Horizontal component |
| `prismHorizontalAxis` | `prism.horizontal.base` | degrees | Base direction (0-360) |
| `prismVerticalValue` | `prism.vertical.value` | prism diopters | Vertical component |
| `prismVerticalAxis` | `prism.vertical.base` | degrees | Base direction (0-360) |
| `prismResultingValue` | `prism.resulting.value` | prism diopters | Combined prism |
| `prismResultingAxis` | `prism.resulting.base` | degrees | Combined direction |

## API Configuration

Unified configuration for both import modes:

```json
{
  "adapters": {
    "eye_office": {
      "import": {
        "mode": "automatic",
        "source": "api",
        "api": {
          "url": "https://eye-office.local:4450/v1",
          "apiKey": "encrypted:...",
          "username": "encrypted:...",
          "password": "encrypted:...",
          "crmExportId": 789,
          "syncInterval": 300
        },
        "data": {
          "visualAcuity": true,
          "prismValues": true,
          "objectiveRefraction": true,
          "subjectiveRefraction": true,
          "import_external": true,
          "import_historical": true
        }
      }
    }
  }
}
```

## API Integration Details

### Authentication Protocol

```http
# Session initialization
POST /v1/login
X-API-KEY: {api_key}
Content-Type: application/json
{
  "user": "{username}",
  "password": "{password}"
}
Response: { "session_id": "{session_id}" }

# Session maintenance
GET /v1/ping
X-API-KEY: {api_key}
Session-ID: {session_id}

# Session termination
GET /v1/logout
X-API-KEY: {api_key}
Session-ID: {session_id}
```

### CRM Filtering Implementation

Patient filtering via CRM criteria:

```http
# Discover Export criterion ID
GET /v1/masterdata/crmcriteria
Response: Tree structure containing { "name": "Export", "id": 789 }

# Query tagged patients
GET /v1/customer?crmcriteria=789&lastChangedGreaterThan=2024-01-01T00:00:00Z
```

### Patient Creation (Optional)

```http
POST /v1/customer
Content-Type: application/json
{
  "branch": 1,
  "firstname": "Max",
  "lastname": "Mustermann",
  "birthday": "2010-03-15"
}
```

### Delta Synchronization

Incremental sync implementation:

```typescript
async function deltaSync(lastSyncTime: DateTime) {
  // Retrieve cached export criterion
  const exportId = await getExportCriterionId();

  // Query modified patients
  const patients = await api.get('/customer', {
    crmcriteria: exportId,
    lastChangedGreaterThan: lastSyncTime.toISO(),
    pageSize: 100
  });

  // Fetch refraction history
  for (const patient of patients.data) {
    const refractions = await api.get('/refraction', {
      customerId: patient.id,
      latestDataOnly: false
    });
  }
}
```

### API Endpoint Reference

| Endpoint | Method | Purpose | Frequency |
|----------|--------|---------|-----------|
| `/v1/login` | POST | Session creation | Startup |
| `/v1/ping` | GET | Session maintenance | 5 minutes |
| `/v1/logout` | GET | Session termination | Shutdown |
| `/v1/masterdata/crmcriteria` | GET | Criterion discovery | Once |
| `/v1/customer` | GET | Patient query | Per sync |
| `/v1/refraction` | GET | Refraction retrieval | Per patient |
| `/v1/customer` | POST | Patient creation | Optional |

## Error Handling Strategy

| Error Scenario | Resolution |
|---------------|------------|
| Connection failure | Exponential backoff retry |
| Session expiration | Automatic re-authentication |
| Missing CRM criterion | Setup wizard activation |
| Missing required fields | Skip record, log error |
| Invalid date format | Default to current date |
| No refraction data | Import demographics only |

## Adapter Implementation

```dart
class EyeOfficeImportAdapter implements ImportAdapter {
  final EyeOfficeApiClient _apiClient;
  final int _crmExportId;

  @override
  String get id => 'eye_office';

  @override
  String get displayName => 'Eye-Office';

  Future<List<ParseResult>> importWithDelta(DateTime lastSync) async {
    // Query modified patients
    final patients = await _apiClient.getCustomers(
      crmcriteria: _crmExportId,
      lastChangedGreaterThan: lastSync,
    );

    final results = <ParseResult>[];

    for (final patient in patients) {
      // Retrieve refraction history
      final refractions = await _apiClient.getRefractions(
        customerId: patient.id,
      );

      // Map patient demographics
      final patientData = {
        'first_name': patient.firstname,
        'last_name': patient.lastname,
        'birth_date': patient.birthday,
        'gender': _mapGender(patient.sex),
      };

      // Extract measurements
      final measurements = <Measurement>[];
      if (refractions.isNotEmpty) {
        final latest = refractions.first;

        if (latest.rightEye != null) {
          measurements.add(_parseRefraction(latest.rightEye, 'right'));
          measurements.add(_parseVisualAcuity(latest.rightEye, 'right'));
        }

        if (latest.leftEye != null) {
          measurements.add(_parseRefraction(latest.leftEye, 'left'));
          measurements.add(_parseVisualAcuity(latest.leftEye, 'left'));
        }
      }

      results.add(ParseResult(
        externalPid: 'eo_${patient.id}',
        patientData: patientData,
        measurements: measurements,
        examDate: refractions.firstOrNull?.date ?? DateTime.now(),
      ));
    }

    return results;
  }
}
```

## Testing Requirements

API-only import requires:
- Mock API responses per OpenAPI specification
- CRM criteria filter validation
- Delta synchronization behavior
- Session lifecycle management

## Current Limitations

Not currently imported:
- Objective refraction data
- Interpupillary distance
- Binocular vision measurements
- Spectacle lens orders
- Contact lens specifications

## Future Export Capability

Potential bidirectional synchronization:

```dart
class EyeOfficeExportAdapter implements ExportAdapter {
  // Patient creation via POST /v1/customer
  // Implementation pending requirements analysis
}
```

Outstanding questions:
- Eye-Office data reception capability
- Updateable field specifications
- Conflict resolution strategy

## Related Documentation

- [Adapter Development](../adapter-development.md)
- [Data Formats](../data-formats.md)
- Eye-Office API documentation in `api-reference/eye-office/`


FILE: adapters/mediworks-al550.md
==================================================

# Mediworks AL550 Import/Export Adapters

ImportAdapter and ExportAdapter implementations for Mediworks AL550 optical biometer.

## Overview

The AL550 adapters provide:
- **ImportAdapter**: Import measurement data from AL550 device
- **ExportAdapter**: Export patient registration to AL550 device

Supported measurements:
- Axial length with OCT technology
- Keratometry and topography
- Anterior segment biometry
- White-to-white and pupil measurements

## ImportAdapter Functionality

### File Format

AL550 exports data as JSON:

```json
{
  "DeviceModel": "AL550",
  "Version": "2.1.0",
  "PatientInfo": {
    "firstname": "Anna",
    "lastname": "Schmidt",
    "patientId": "0000000015",
    "gender": "F",
    "birthday": "2010-04-12"
  },
  "Cases": [{
    "CheckTime": "2024-08-15T10:30:00Z",
    "OD": {
      "AxialCase": {
        "Data": {
          "dataFilter": [23.67, 0.542, 3.12, 4.14],
          "snrData": [12.5, 8.2, 11.1, 9.8]
        }
      },
      "TopographyCase": {
        "Data": {
          "CorneaFront": {
            "K1": 43.11,
            "K2": 44.36,
            "Rf": 7.83,
            "Rs": 7.61,
            "AxisFlat": 172,
            "AxisSteep": 82,
            "Astig": 1.25
          }
        }
      },
      "WTWCase": {
        "Data": {
          "wtw": { "r": 5.9 },
          "pupil": { "r": 2.1 }
        }
      }
    },
    "OS": { /* Left eye data */ }
  }]
}
```

### Data Mapping

**Axial Measurements:**
```
dataFilter[0] â†’ Axial length (mm)
dataFilter[1] â†’ Corneal thickness (mm)
dataFilter[2] â†’ Anterior chamber depth (mm)
dataFilter[3] â†’ Lens thickness (mm)
```

**Field Mappings:**

| AL550 | DATEYE | Unit | Notes |
|-------|--------|------|-------|
| `AxialCase.Data.dataFilter[0]` | `axial_length.value` | mm | |
| `AxialCase.Data.snrData[0]` | `axial_length.snr` | - | Signal quality |
| `TopographyCase.Data.CorneaFront.K1` | `cornea.k1_d` | D | |
| `TopographyCase.Data.CorneaFront.Rf` | `cornea.k1_mm` | mm | |
| `TopographyCase.Data.CorneaFront.K2` | `cornea.k2_d` | D | |
| `TopographyCase.Data.CorneaFront.Rs` | `cornea.k2_mm` | mm | |
| `WTWCase.Data.wtw.r` | `white_to_white.horizontal` | mm | Ã— 2 (radius to diameter) |
| `WTWCase.Data.pupil.r` | `pupil.photopic` | mm | Ã— 2 (radius to diameter) |

## ExportAdapter Functionality

### Patient Registration

Patients must be registered before measurements:

```http
POST /setPatients
Content-Type: multipart/form-data

------WebKitFormBoundary
Content-Disposition: form-data; name="file"; filename="patients.json"

[
  {
    "patientId": "0000000015",
    "firstname": "Anna",
    "lastname": "Schmidt",
    "gender": "F",
    "birthday": "2010-04-12",
    "refractiveSurgery": "NONE"
  }
]
------WebKitFormBoundary--
```

### API Endpoints

| Endpoint | Method | Purpose |
|----------|--------|---------|
| `/getPatients` | GET | Retrieve registered patients |
| `/setPatients` | POST | Register new patients |

Default URL: `http://<device-ip>:8080`

### Export Flow

1. Check existing patients - GET /getPatients
2. Compare with DATEYE - Find new patients
3. Prepare upload - Format patient data
4. Send to device - POST /setPatients
5. Log results - Track success/failure

### Gender Mapping

| DATEYE | AL550 |
|--------|-------|
| `male` | `M` |
| `female` | `F` |
| `other` | `F` |
| `unknown` | `F` |

## Configuration

```json
{
  "adapters": {
    "mediworks_al550": {
      "import": {
        "path": "/import/al550/",
        "delete_after_import": true,
        "quality": {
          "min_snr": 5.0
        }
      },
      "export": {
        "targets": [{
          "id": "al550_main",
          "name": "AL550 HauptgerÃ¤t",
          "host": "192.168.1.100",
          "port": 8080,
          "auto_export": true
        }]
      }
    }
  }
}
```

## Quality Validation

### SNR Thresholds
- Minimum: 5.0 for reliable measurements
- Warning: 2.0-5.0 (import with flag)
- Reject: < 2.0

### Range Validation

| Measurement | Normal | Extended | Action |
|-------------|--------|----------|--------|
| Axial Length | 22-26mm | 20-30mm | Flag if outside |
| Keratometry | 40-48D | 38-50D | Flag if outside |
| ACD | 2.5-4.0mm | 2.0-5.0mm | Flag if outside |
| Lens Thickness | 3.5-5.0mm | 3.0-6.0mm | Flag if outside |

## Adapter Implementation

```dart
class MediworksAL550Adapter extends DataAdapter {
  @override
  String get id => 'mediworks_al550';

  @override
  Future<ParseResult?> parseFile(File file) async {
    if (!file.path.endsWith('.json')) return null;

    final json = jsonDecode(await file.readAsString());

    if (json['DeviceModel'] != 'AL550') return null;

    // Extract patient
    final patient = {
      'first_name': json['PatientInfo']['firstname'],
      'last_name': json['PatientInfo']['lastname'],
      'birth_date': json['PatientInfo']['birthday'],
      'gender': _mapGender(json['PatientInfo']['gender']),
    };

    // Extract measurements
    final measurements = <Measurement>[];

    for (final examCase in json['Cases']) {
      final examTime = DateTime.parse(examCase['CheckTime']);

      // Process each eye
      for (final eye in ['OD', 'OS']) {
        final eyeData = examCase[eye];
        if (eyeData == null) continue;

        final eyeSide = eye == 'OD' ? 'right' : 'left';

        // Axial length
        if (eyeData['AxialCase'] != null) {
          final data = eyeData['AxialCase']['Data'];
          measurements.add(Measurement('axial_length', {
            'eye': eyeSide,
            'value': data['dataFilter'][0],
            'snr': data['snrData'][0],
            'measured_at': examTime.toIso8601String(),
          }));
        }

        // Keratometry
        if (eyeData['TopographyCase'] != null) {
          final cornea = eyeData['TopographyCase']['Data']['CorneaFront'];
          measurements.add(Measurement('cornea', {
            'eye': eyeSide,
            'k1_d': cornea['K1'],
            'k1_mm': cornea['Rf'],
            'k2_d': cornea['K2'],
            'k2_mm': cornea['Rs'],
            'axis_k1': cornea['AxisFlat'],
            'axis_k2': cornea['AxisSteep'],
            'astigmatism': cornea['Astig'],
          }));
        }
      }
    }

    return ParseResult(
      externalPid: 'al550_${json['PatientInfo']['patientId']}',
      patientData: patient,
      measurements: measurements,
      examDate: examTime.toLocal(),
    );
  }

  @override
  Future<void> exportData(Map<String, dynamic> event, ExportTarget target) async {
    // Get decrypted patient data
    final patient = await getPatientData(event['secret_pid']);

    // Check if patient exists on device
    final existing = await _getExistingPatients(target);

    if (_patientExists(existing, patient)) {
      return; // Already registered
    }

    // Prepare patient data
    final payload = [{
      'patientId': patient['external_ids']?['al550'] ??
                   _generatePatientId(),
      'firstname': patient['first_name'],
      'lastname': patient['last_name'],
      'gender': _mapGenderToAL550(patient['gender']),
      'birthday': patient['birth_date'],
      'refractiveSurgery': 'NONE',
    }];

    // Send to device
    final response = await http.post(
      Uri.parse('http://${target.config['host']}:${target.config['port']}/setPatients'),
      headers: {'Content-Type': 'multipart/form-data'},
      body: _createMultipartBody(payload),
    );

    if (response.body != 'ok') {
      throw Exception('AL550 registration failed');
    }
  }
}
```

## Error Handling

| Error | Import | Export |
|-------|--------|--------|
| Network timeout | N/A | Retry with backoff |
| Invalid JSON | Skip file | N/A |
| Missing required field | Import partial | Skip patient |
| Device offline | N/A | Queue for retry |
| Duplicate patient | N/A | Skip silently |

## Testing

Test files in `test/fixtures/mediworks-al550/`:
- `complete_exam.json` - Bilateral measurements
- `single_eye.json` - Monocular patient
- `low_quality.json` - Poor SNR values
- `patient_export.json` - Export format

## Limitations

The AL550 does not provide:
- Refraction data
- Visual acuity
- Subjective measurements
- IOL calculations (separate module)

## Troubleshooting

### Import Issues
- Check JSON structure
- Verify file permissions
- Review quality thresholds

### Export Issues
- Ping device IP address
- Check port 8080 is open
- Verify network connectivity
- Maximum 10,000 patients on device

## API Reference

Complete AL550 API documentation available in `api-reference/mediworks/`

## Related Documentation

- [Adapter Development](../adapter-development.md)
- [Data Formats](../data-formats.md)
- [AL550 API Documentation](../external-apis/mediworks/README.md)



FILE: external-apis/eye-office/README.md
==================================================

# Eye-Office API Documentation

API specification for Eye-Office practice management software integration.

## Files

- `eye-office-api-1.yaml` - OpenAPI 3.0 specification with CRM criteria support
- `Eye-Office API V0_1-3.pdf` - Complete API documentation

## API Overview

Eye-Office provides a REST API for accessing patient and refraction data from their practice management system. The API uses session-based authentication with existing Eye-Office user credentials.

## Authentication

All requests require:
- Header: `X-API-KEY` - Provided by Eye-Office support
- Header: `Session-ID` - Obtained from login endpoint

### Session Management
```http
POST /v1/login          # Authenticate and obtain session
GET  /v1/ping           # Keep session alive (5-minute intervals)
GET  /v1/logout         # End session
```

## Core Endpoints

### Patient Management
```http
GET  /v1/customer           # List patients with optional CRM filtering
GET  /v1/customer/{id}      # Get specific patient details
POST /v1/customer           # Create new patient
```

Query parameters:
- `crmcriteria` - Filter by CRM criterion ID
- `lastChangedGreaterThan` - Delta synchronization support

### Refraction Data
```http
GET  /v1/refraction         # Get patient refraction history
GET  /v1/refraction/{id}    # Get specific refraction
```

Query parameters:
- `customerId` - Required patient identifier
- `latestDataOnly` - Return only current prescription

### CRM Criteria
```http
GET  /v1/masterdata/crmcriteria    # Get all CRM criteria for filtering
```

## Data Models

### Customer (Patient)
```json
{
  "id": 12345,
  "firstname": "Anna",
  "lastname": "Schmidt",
  "birthday": "2010-03-15",
  "sex": "female",
  "internalData": {
    "refraction": {
      "date": "2024-01-15",
      "refrRight": {
        "useForOrder": true,
        "sphere": -2.25,
        "cylinder": -0.50,
        "axisCylinder": 90,
        "addition": 0,
        "visusSc": 0.5,
        "visusCc": 1.0,
        "prismHorizontalValue": 0,
        "prismVerticalValue": 0
      }
    }
  }
}
```

### Key Fields
- `internalData.refraction` - Contains trusted refraction values
- `useForOrder` - Boolean flag indicating current prescription
- Visual acuity values: `visusSc` (without correction), `visusCc` (with correction)
- Complete prism data: horizontal, vertical, and resulting values

## Integration Notes

Eye-Office serves as a data source for:
1. Patient demographics
2. Historical refraction data
3. Practice management synchronization

Delta synchronization is supported via the `lastChangedGreaterThan` parameter for efficient updates.

## Related Documentation

- [Eye-Office Adapter Implementation](../../adapters/eye-office.md)
- [Data Formats](../../data-formats.md)



FILE: external-apis/mediworks/README.md
==================================================

# Mediworks AL550 API Documentation

API documentation for Mediworks AL550 biometer integration.

## Documentation Files

### English Documentation
- `getPatients-en.md` - GET endpoint for retrieving patient list
- `setPatients-en.md` - POST endpoint for patient registration
- `AL550ExportFile-EN.md` - Export file format specification
- `Explanation of the Interface.docx` - Integration overview

### Chinese Documentation
- `getPatients-zh.md` - GETæ‚£è€…åˆ—è¡¨æ¥å£
- `setPatients-zh.md` - POSTæ‚£è€…æ³¨å†Œæ¥å£
- `AL550ExportFile-ZH.md` - å¯¼å‡ºæ–‡ä»¶æ ¼å¼è¯´æ˜

### Technical Resources
- `AL550ExportFile.json` - Example export file
- `caseData.xml` - Sample case data format

## API Reference

### Connection
```
Base URL: http://<device_ip>:<port>
Default Port: 8080
Authentication: None (trusted local network)
```

### Endpoints
```http
GET  /getPatients    # Retrieve all registered patients
POST /setPatients    # Register new patients for measurement
```

## Data Flow

### Patient Registration (DATEYE â†’ AL550)
1. Export patient demographics from DATEYE
2. POST to `/setPatients` endpoint
3. Patient available for measurement on device

### Measurement Import (AL550 â†’ DATEYE)
1. Perform measurements on AL550
2. Export as JSON file from device
3. Import file into DATEYE

## Data Model

### Key Identifiers
- `patientId` - AL550 internal patient identifier
- `pid` - System-generated unique ID
- `Cases` - Container for examination data
- `OD`/`OS` - Right eye / Left eye data structures

### File Format
Complete specification available in `AL550ExportFile-EN.md`. JSON structure includes:
- Patient demographics
- Multiple examination cases
- Detailed measurement data per eye
- Quality metrics and metadata

## Related Documentation

- [Mediworks AL550 Adapter](../../adapters/mediworks-al550.md)
- [Data Formats](../../data-formats.md)



FILE: external-apis/mediworks/AL550ExportFile-EN.md
==================================================

# AL550ExportFile Field Descriptions

## Object: AL550ExportFile

- **DeviceModel** (`string`): Device model.
- **Version** (`string`): Device software version.

### Calibration Data

- **anchor** (Anchor Data)

  - **x**, **y** (`integer`): X and Y coordinates of the calibrated ring center.
  - **r1**, **r2**, **r3** (`integer`): Three radius parameters for auxiliary ring identification.
- **motorCenter** (Motor Center Position)

  - **x**, **y**, **z** (`integer`): X, Y, Z coordinates when centered.
- **octParas** (OCT Parameters)

  - **zerostart1**, **zerostart2** (`integer`): Zero-start positions.
  - **topopos1**, **topopos2**, **octpos1**, **octpos2** (`integer`): Corneal topography and OCT capture positions.
  - **imagescale** (`integer`): Image scale ratio.
  - **imageshowlabel** (`integer`): Image display label (0 or 1).
  - **rulmean**, **frethres** (`integer`): Mean value and frequency threshold of ruler signal.
  - **halfwavelength1**, **halfwavelength2** (`float`): Two half-wavelength values.
  - **signaloffset1**, **signaloffset2**, **signaloffset3**, **signaloffset4**, **signaloffset5**, **signaloffset6** (`integer`): Six signal offset values.
  - **ruldividepos** (`integer`): Ruler signal division position.
  - **signaloffset** (`integer`): Base signal offset.
  - **threcorneapos1**, **threcorneapos2** (`integer`): Corneal position thresholds.
  - **threcorneathick1**, **threcorneathick2** (`integer`): Corneal thickness thresholds.
  - **threacdepth1**, **threacdepth2** (`integer`): Anterior chamber depth thresholds.
  - **threlensthick1**, **threlensthick2** (`integer`): Lens thickness thresholds.
  - **threretinapos1**, **threretinapos2** (`integer`): Retina position thresholds.
  - **threcornea1**, **threcornea2** (`integer`): Corneal parameters.
  - **threretina2lensb1**, **threretina2lensb2** (`integer`): Retina-to-lens-back distance.
  - **threretina2lensf1**, **threretina2lensf2** (`integer`): Retina-to-lens-front distance.
  - **threretina2corneaf1**, **threretina2corneaf2** (`integer`): Retina-to-cornea distance.
  - **refractiveindex0**, **refractiveindex1**, **refractiveindex2**, **refractiveindex3** (`array of float`): Array of refractive indices for four different eye structures.
  - **CCT_offset** (`float`): Corneal central thickness offset.
- **rendercfg** (Rendering Configuration)

  - **w**, **h** (`integer`): Rendering width and height.
  - **x**, **y** (`integer`): Rendering position coordinates.
  - **flip** (Flip Configuration)
    - **x**, **y** (`integer`): Flip configuration for x and y axes.
- **cam_lamp** (Camera and Lamp Configuration)

  - **fixedLight** (Fixed Light Configuration)
    - **brightness** (`integer`): Brightness of the fixed light.
  - **axislength** (Axis Length Configuration)
    - **cam** (Camera Settings)
      - **rgain**, **ggain**, **bgain** (`integer`): Red, green, blue gain.
      - **blacklevel** (`float`): Black level.
      - **gamma** (`float`): Gamma value.
    - **lamp** (Lamp Settings)
      - **infrared**, **red**, **green** (`boolean`): Switches for infrared, red, and green lights.
      - **ir_lightness** (`float`): Infrared light brightness.
      - **center_ring_lightness**, **middle_ring_lightness**, **outer_ring_lightness** (`float`): Brightness of center, middle, and outer ring lights.
- **Laser** (Laser Position)

  - **x**, **y** (`integer`): X and Y coordinates of the laser.
- **focusThreshold** (Focus Threshold)

  - **axisLength**, **topography** (`integer`): Focus threshold for axis length and topography.
- **dstPath** (`string`): Image destination path.
- **CAMERA_pixelsize** (`float`): Camera pixel size.
- **coarse**, **fine**, **ir**, **green** (`string`): Paths for four model files.
- **pupil**, **wtw** (`string`): File paths for pupil and white-to-white.
- **initX**, **initY**, **initZ** (`integer`): Initial position coordinates X, Y, Z.
- **maxFrontPos**, **maxBackPos** (`integer`): Maximum front and back positions.
- **PZ_Motor_A**, **PZ_Motor_B** (`integer`): Motor parameters.
- **AE** (`integer`): Auto-exposure value.
- **cam_lamp_1** (Alternative Lamp Configuration, same structure as `cam_lamp`).
- **focusThreshold_new** (New Focus Threshold)

  - **axisLength**, **topography** (`integer`): New focus threshold for axis length and topography.
- **isNew** (`boolean`): Indicates if it is a new version.

### Patients

- **PatientInfo** (Basic patient information)

  - **_id**, **_rev** (`string`): Unique identifier in the database.
  - **firstname**, **lastname** (`string`): Patient's first and last name.
  - **patientId** (`integer`): Patient ID number.
  - **gender** (`string`): Gender ("M" or "F").
  - **birthday** (`string`): Birth date.
  - **address**, **phone**, **email** (`string`): Contact information.
  - **refractiveSurgery** (`string`): Type of refractive surgery.
  - **age** (`integer`): Patient age.
  - **status** (`string`): Status (e.g., "checked").
  - **pid** (`integer`): Patient ID code.
  - **checkTime**, **createTime**, **updateTime** (`integer`): Check, creation, and update time (UNIX timestamp).
  - **isDeleted** (`boolean`): Indicates if the record is deleted.

- **Cases** (Examination records)

  - **CheckTime** (`string`): Time of examination.
  - **OD**, **OS** (Data for the right and left eye)
    - **EyeType** (`string`): Eye type ("Right" or "Left").
    - **CheckType** (`string`): Type of examination.
    - **TopographyCase** (Topography data)

      - **Data**
        - **QS** (Quality Score)
          - **OffsetX**, **OffsetY**, **OffsetZ** (`integer`): Offset values.
          - **AreaU**, **AreaD**, **AreaA** (`float`): Area measurements.
          - **HeightU**, **HeightD** (`integer`): Height values.
          - **TearN**, **TearA** (`integer`): Tear parameters.
        - **CorneaFront** (Corneal front surface data)
          - **K1**, **K2**, **Km**, **Kmax** (`float`): Corneal curvature values.
          - **Astig** (`float`): Astigmatism.
          - **AxisFlat**, **AxisSteep** (`integer`): Flat and steep axis.
          - **Rf**, **Rs**, **Rh**, **Rv**, **Rm** (`float`): Radius of curvature parameters.
          - **Rper**, **RminX**, **RminY**, **Rmin** (`float`): Radius-related parameters.
          - **SRI**, **SAI**, **IS** (`float`): Corneal asymmetry indices.

    - **AxialCase** (Axial data)

      - **Data**
        - **data** contains specific OCT measurements
          - **value** (`array of float`): Measurement values.
          - **fixed** (`integer`): Number of decimal places.
          - **scale** (`integer`): Unit conversion scale.
        - **dataFilter** (Filtered OCT data, same format as `data`)
        - **chartData** (`array`): Array of chart data.
        - **positionData** (`array of integer`): Coordinates for each layer's recognized position.
        - **snrData** (`array of float`): SNR data used for filtering and display.
        - **thresholdData** (`array of float`): Threshold data used for filtering.

    - **WTWCase** (White-to-white data)

      - **Data**
        - **pupil** (Pupil data)
          - **x**, **y** (`float`): X and Y coordinates of pupil center.
          - **r** (`float`): Pupil radius.
        - **wtw** (White-to-white data)
          - **x**, **y** (`float`): X and Y coordinates of WTW center.
          - **r** (`float`): WTW radius.
        - **center** (Center position)
          - **x**, **y** (`integer`): Center X and Y coordinates.
        - **kapa** (`object`): Kappa angle coordinates
          - **x**, **y** (`float`): X and Y values of the Kappa angle.
        - **alpha** (`object`): Alpha angle coordinates
          - **x**, **y** (`float`): X and Y values of the Alpha angle.
        - **imageurl** (`string`): URL of the pupil image.

    - **Map** (Topography map data)

      - **Data**
        - **CornealHeight** (Corneal height data)

          - **Cols**, **Rows** (`integer`): Number of columns and rows in the data grid.
          - **InvalidDataValue** (`integer`): Value marking invalid data.
          - **WorldCoords** (World coordinate range)
            - **Low** (`object`): Lowest X and Y coordinates.
              - **X**, **Y** (`float`): Minimum X and Y values.
            - **High** (`object`): Highest X and Y coordinates.
              - **X**, **Y** (`float`): Maximum X and Y values.
          - **MinimumValue**, **MaximumValue** (`string`): Minimum and maximum values in the data.
          - **Data** (`string`): Specific corneal height data.

        - **SagitalCurvatureFront** (Sagittal curvature data)

          - **Cols**, **Rows** (`integer`): Number of columns and rows in the data grid.
          - **InvalidDataValue** (`integer`): Value marking invalid data.
          - **WorldCoords** (World coordinate range)
            - **Low** (`object`): Lowest X and Y coordinates.
              - **X**, **Y** (`float`): Minimum X and Y values.
            - **High** (`object`): Highest X and Y coordinates.
              - **X**, **Y** (`float`): Maximum X and Y values.
          - **MinimumValue**, **MaximumValue** (`string`): Minimum and maximum values in the data.
          - **Data** (`string`): Specific sagittal curvature data.



FILE: external-apis/mediworks/getPatients-en.md
==================================================

# API Documentation

## GET /getPatients
```http
GET /getPatients HTTP/1.1
Host: xxx.example.com
Content-Type: application/json
```

### Description

This endpoint retrieves a list of patients.

### Request

No request parameters are required.

### Response

The response is an array of `IPatient` objects. Each `IPatient` object contains the following fields:

```ts
interface IPatient {
  firstname: string;
  lastname: string;
  patientId: string;
  gender: 'M' | 'F';
  birthday: string;
  address: string | '';
  phone: string | '';
  email: string | '';
  refractiveSurgery: 'D' | 'NONE' | 'LASIK' | 'PRK';
  age: number;
  status: 'unchecked';
  pid: string;
  checkTime: number;
  createTime: number;
  isDeleted: boolean;
  updateTime: number;
}

```

#### `IPatient` Interface Fields

| **Field**           | **Type**                                    | **Description**                                                                                                        |
|---------------------|---------------------------------------------|------------------------------------------------------------------------------------------------------------------------|
| `firstname`         | `string`                                    | The first name of the patient.                                                                                         |
| `lastname`          | `string`                                    | The last name of the patient.                                                                                          |
| `patientId`         | `string`                                    | The unique identifier of the patient.                                                                                  |
| `gender`            | `'M'` \| `'F'`                              | The gender of the patient. Possible values: <br> `'M'`: Male <br> `'F'`: Female                                        |
| `birthday`          | `string`                                    | The patient's date of birth in YYYY-MM-DD format.                                                                      |
| `address`           | `string` \| `''`                            | The patient's address. It can be an empty string if no address is provided.                                            |
| `phone`             | `string` \| `''`                            | The patient's phone number. It can be an empty string if no phone number is provided.                                   |
| `email`             | `string` \| `''`                            | The patient's email address. It can be an empty string if no email is provided.                                         |
| `refractiveSurgery`  | `'D'` \| `'NONE'` \| `'LASIK'` \| `'PRK'`   | The type of refractive surgery the patient has undergone, if any. Possible values: <br> `'D'`: Diagnosed <br> `'NONE'`: No surgery <br> `'LASIK'`: LASIK surgery <br> `'PRK'`: PRK surgery |
| `age`               | `number`                                    | The age of the patient.                                                                                                |
| `status`            | `'unchecked'`                               | The current status of the patient's record.                                                                            |
| `pid`               | `string`                                    | The unique patient ID in the system.                                                                                   |
| `checkTime`         | `number`                                    | The Unix timestamp (in milliseconds) of the patient's last check-in.                                                   |
| `createTime`        | `number`                                    | The Unix timestamp (in milliseconds) when the patient's record was created.                                             |
| `isDeleted`         | `boolean`                                   | A flag indicating whether the patient's record has been deleted.                                                       |
| `updateTime`        | `number`                                    | The Unix timestamp (in milliseconds) when the patient's record was last updated.                                        |

### Example Response

```json
[
  {
    "firstname": "JJ",
    "lastname": "Yang",
    "patientId": "0000000015",
    "gender": "M",
    "birthday": "2024-08-14",
    "address": "test",
    "phone": "12332111223",
    "email": "123@example.com",
    "refractiveSurgery": "D",
    "age": 0,
    "status": "unchecked",
    "pid": "7230042280986583040",
    "checkTime": 1723776407477,
    "createTime": 1723779287478,
    "isDeleted": false,
    "updateTime": 1723779287478
  },
  {
    "firstname": "Emily",
    "lastname": "Smith",
    "patientId": "0000000016",
    "gender": "F",
    "birthday": "1985-03-23",
    "address": "123 Main St",
    "phone": "5551234567",
    "email": "emily.smith@example.com",
    "refractiveSurgery": "NONE",
    "age": 39,
    "status": "checked",
    "pid": "7230042280986583041",
    "checkTime": 1723776407480,
    "createTime": 1723779287481,
    "isDeleted": false,
    "updateTime": 1723779287482
  }
]
```



FILE: external-apis/mediworks/setPatients-en.md
==================================================

# API Documentation

## POST /setPatients

### Description

This endpoint is used to upload a patient data file. The server processes the uploaded file and returns a simple response.

### Request

- **HTTP Method**: POST
- **Endpoint**: /setPatients
- **Content Type**: multipart/form-data

#### Request Parameters


| Parameter | Type | Required | Description                                                           |
| --------- | ---- | -------- | --------------------------------------------------------------------- |
| file      | File | Yes      | The patient data file to upload. The file field must be named "file". |

The endpoint uses `upload.single("file")` middleware to handle a single file upload, so the request must include a file field with the name "file".

### Response

- **HTTP Status Code**: 200 OK
- **Content Type**: text/plain

#### Response Example:

ok



FILE: external-apis/zeiss/README.md
==================================================

# ZEISS API Documentation

API specifications and data structures for ZEISS ophthalmic devices.

## Supported Devices

| Device | Model | Documentation |
|--------|-------|---------------|
| IOLMaster 700 | Swept-source OCT biometer | [DICOM API Reference](IOLMaster700Types.md) |
| IOLMaster 500 | Partial coherence interferometry | Planned |

## DICOM Integration

ZEISS devices export measurement data using DICOM standards.

### DICOM SOP Classes

- **Ophthalmic Axial Measurements Storage** - Axial length, ACD, lens thickness
- **Keratometry Measurements Storage** - Corneal curvature measurements
- **Intraocular Lens Calculations Storage** - IOL power calculations
- **Ophthalmic Photography 8 Bit Image Storage** - Reference images
- **Encapsulated PDF Storage** - Measurement reports

### Data Flow
```
ZEISS Device â†’ DICOM Export â†’ DATEYE Import â†’ Standardized Events
```

## IOLMaster 700 Specifications

### Available Measurements
- **Axial Length** - Swept-source OCT with segmental measurements
- **Keratometry** - Standard and Total Keratometry (licensed feature)
- **Anterior Chamber Depth** - High precision measurement
- **Lens Thickness** - Crystalline lens measurement
- **White-to-White** - Corneal diameter with offset measurements
- **Pupil Size** - Photopic conditions
- **IOL Calculations** - Multiple formulas (Haigis, SRK-T, Barrett)

### Quality Metrics
- Signal-to-noise ratios for axial measurements
- Standard deviations for composite values
- Quality indicators per measurement type
- Automatic validation flags

### Data Precision
- Axial Length: Â±0.01 mm
- Keratometry: Â±0.01 D
- Automatic reliability assessment

## DICOM Implementation Details

### Instance Structure
ZEISS creates multiple related DICOM instances per examination:
- **Performed Procedure Step ID** - Groups related measurements
- **Study Instance UID** - Links examination data
- **Cross-references** - Images reference measurement instances

### Private DICOM Tags
ZEISS uses private tags for:
- Extended quality metrics
- Additional measurement parameters
- Device-specific calculations
- Clinical patient information

## DATEYE Integration

### Import Process
1. Parse and validate DICOM structure
2. Extract biometric data by SOP Class
3. Process quality metrics and validation
4. Convert to DATEYE measurement schema
5. Maintain relationships between measurements

### Supported Workflows
- **Manual Import** - DICOM files in import folder
- **Batch Processing** - Multiple examinations per export

## Related Documentation

- [ZEISS IOLMaster Adapter](../../adapters/zeiss-iolmaster.md)
- [Data Formats](../../data-formats.md)



FILE: external-apis/zeiss/IOLMaster700Types.md
==================================================

# ZEISS IOLMaster 700 DICOM API Reference

Complete DICOM structure reference for IOLMaster 700 integration

## Overview

The IOLMaster 700 exports comprehensive biometric measurement data using standard DICOM Information Object Definitions (IODs). This document provides the complete structure reference for DATEYE integration.

## DICOM SOP Classes

### Measurement SOP Classes

| SOP Class | UID | Purpose |
|-----------|-----|---------|
| Ophthalmic Axial Measurements Storage | 1.2.840.10008.5.1.4.1.1.78.7 | Axial length, ACD, lens thickness |
| Keratometry Measurements Storage | 1.2.840.10008.5.1.4.1.1.78.3 | Corneal curvature measurements |
| Intraocular Lens Calculations Storage | 1.2.840.10008.5.1.4.1.1.78.8 | IOL power calculations |

### Image SOP Classes

| SOP Class | UID | Purpose |
|-----------|-----|---------|
| Ophthalmic Photography 8 Bit Image Storage | 1.2.840.10008.5.1.4.1.1.77.1.5.1 | Scleral, white-to-white images |
| Multi-frame Grayscale Byte Secondary Capture | 1.2.840.10008.5.1.4.1.1.7.2 | Quality control images |
| Encapsulated PDF Storage | 1.2.840.10008.5.1.4.1.1.104.1 | Measurement reports |

## Ophthalmic Axial Measurements IOD

### Core Measurement Structure

```typescript
interface OphthalmicAxialMeasurements {
  // Device identification
  ophthalmicAxialMeasurementsDeviceType: "OPTICAL";

  // Anterior chamber depth definition
  anteriorChamberDepthDefinition: "Front Of Cornea To Front Of Lens";

  // Right eye measurements (if measured)
  ophthalmicAxialMeasurementsRightEye?: {
    lensStatus: LensStatus;
    vitreousStatus: VitreousStatus;
    pupilDilated?: "YES" | "NO";
    ophthalmicAxialLengthMeasurements: AxialLengthMeasurement[];
    opticalSelectedOphthalmicAxialLength?: SelectedAxialLength[];
  };

  // Left eye measurements (if measured)
  ophthalmicAxialMeasurementsLeftEye?: {
    // Same structure as right eye
  };
}
```

### Axial Length Measurement Types

```typescript
interface AxialLengthMeasurement {
  ophthalmicAxialLengthMeasurementsType: "TOTAL LENGTH" | "SEGMENTAL LENGTH";

  // For total length measurements
  ophthalmicAxialLengthMeasurementsTotalLength?: {
    ophthalmicAxialLength: number; // mm
    ophthalmicAxialLengthMeasurementModified: "YES" | "NO";
    referencedOphthalmicAxialLengthMeasurementQCImage: ImageReference;
    opticalOphthalmicAxialLengthMeasurements: {
      ophthalmicAxialLengthDataSource: DataSource;
      ophthalmicAxialLengthDataSourceDescription: string;
    };
  }[];

  // For segmental measurements
  ophthalmicAxialLengthMeasurementsSegmentalLength?: {
    ophthalmicAxialLength: number; // mm
    ophthalmicAxialLengthMeasurementModified: "YES" | "NO";
    ophthalmicAxialLengthMeasurementsSegmentName: SegmentName;
    opticalOphthalmicAxialLengthMeasurements: {
      ophthalmicAxialLengthDataSource: DataSource;
      ophthalmicAxialLengthDataSourceDescription: string;
    };
  }[];
}
```

### Segment Names (Standard)

```typescript
type SegmentName =
  | "T-AA200"   // Cornea
  | "T-AA050"   // Anterior Chamber
  | "111778"    // Single or Anterior Lens
  | "IOLM_AQD"; // Aqueous Depth (private)
```

### Quality Metrics

```typescript
interface QualityMetric {
  conceptNameCode: QualityMetricType;
  numericValue: number;
  measurementUnitsCode: {
    codeValue: "1";
    codingSchemeDesignator: "UCUM";
    codeMeaning: "no units";
  };
}

type QualityMetricType =
  | "111786"      // Standard Deviation of measurements used
  | "IOLM_QUALITY"; // IOLMaster Quality Metric (private)
```

### Selected Axial Length (Composite Results)

```typescript
interface SelectedAxialLength {
  ophthalmicAxialLengthMeasurementsType: "TOTAL LENGTH" | "SEGMENTAL LENGTH";

  selectedTotalOphthalmicAxialLength?: {
    ophthalmicAxialLength: number; // mm (composite value)
    referencedOphthalmicAxialLengthMeasurementQCImage: ImageReference;
    ophthalmicAxialLengthQualityMetric: QualityMetric;
  };

  selectedSegmentalOphthalmicAxialLength?: {
    ophthalmicAxialLengthMeasurementsSegmentName: SegmentName;
    ophthalmicAxialLength: number; // mm (composite value)
    referencedOphthalmicAxialLengthMeasurementQCImage: ImageReference;
    ophthalmicAxialLengthQualityMetric: QualityMetric;
  }[];
}
```

## Keratometry Measurements IOD

### Core Structure

```typescript
interface KeratometryMeasurements {
  // Right eye keratometry (if measured)
  keratometryRightEye?: {
    steepKeratometricAxis: {
      radiusOfCurvature: number; // mm
      keratometricPower: number;  // diopters
      keratometricAxis: number;   // degrees
    };
    flatKeratometricAxis: {
      radiusOfCurvature: number; // mm
      keratometricPower: number;  // diopters
      keratometricAxis: number;   // degrees
    };
  };

  // Left eye keratometry (if measured)
  keratometryLeftEye?: {
    // Same structure as right eye
  };
}
```

### Extended Keratometry (Private Extensions)

```typescript
interface ExtendedKeratometry {
  // Quality information for each eye
  iolmasterKeratometryQualityRightEye?: {
    extendedSteepKeratometricAxis?: {
      standardDeviationOfKeratometryMeasurement?: number; // mm
    };
    extendedFlatKeratometricAxis?: {
      standardDeviationOfKeratometryMeasurement?: number; // mm
    };
    iolmasterQualityIndicator?: "SUCCESSFUL" | "WARNING" | "FAILED" | "NONE";
    standardDeviationOfSphericalEquivalent?: number; // mm
    referencedKeratometryMeasurementQCImage: {
      referencedSOPClassUID: "1.2.840.10008.5.1.4.1.1.7.2";
      referencedSOPInstanceUID: string;
    };
  };

  // Posterior cornea surface measurements (requires license)
  iolmasterPosteriorCorneaSurfaceRightEye?: {
    steepPosteriorCorneaSurface?: {
      posteriorRadiusOfCurvature?: number; // mm
      posteriorKeratometricPower?: number;  // diopters
      posteriorKeratometricAxis?: number;   // degrees
      standardDeviationOfKeratometryMeasurement?: number; // mm
    };
    flatPosteriorCorneaSurface?: {
      posteriorRadiusOfCurvature?: number; // mm
      posteriorKeratometricPower?: number;  // diopters
      posteriorKeratometricAxis?: number;   // degrees
      standardDeviationOfKeratometryMeasurement?: number; // mm
    };
    iolmasterQualityIndicator?: "SUCCESSFUL" | "WARNING" | "FAILED" | "NONE";
    standardDeviationOfSphericalEquivalent?: number; // mm
    indexOfRefractionOfTheCornea: number;
    indexOfRefractionOfTheAqueousHumor: number;
  };

  // Total keratometry measurements (requires license)
  iolmasterTotalKeratometryRightEye?: {
    steepTotalKeratometry: {
      totalKeratometryRadiusOfCurvature: number; // mm
      totalKeratometryPower: number; // diopters
      totalKeratometryAxis: number;  // degrees
      standardDeviationOfTotalKeratometry?: number; // mm
    };
    flatTotalKeratometry: {
      totalKeratometryRadiusOfCurvature: number; // mm
      totalKeratometryPower: number; // diopters
      totalKeratometryAxis: number;  // degrees
      standardDeviationOfTotalKeratometry?: number; // mm
    };
    iolmasterQualityIndicator?: "SUCCESSFUL" | "WARNING" | "FAILED" | "NONE";
    standardDeviationOfTotalKeratometrySphericalEquivalent?: number; // mm
  };
}
```

## Intraocular Lens Calculations IOD

### Core Structure

```typescript
interface IntraocularLensCalculations {
  // Right eye calculations (if performed)
  intraocularLensCalculationsRightEye?: {
    targetRefraction: number; // diopters
    refractiveProcedureOccurred?: "YES" | "NO";
    refractiveSurgeryType?: RefractiveSurgeryType[];
    refractiveErrorBeforeRefractiveSurgery?: RefractiveErrorType;

    // Measurement inputs used for calculation
    cornealSize?: {
      cornealSize: number; // mm (horizontal diameter)
      sourceOfCornealSizeData: DataSource;
    };
    lensThickness?: {
      lensThickness: number; // mm
      sourceOfLensThicknessData: DataSource;
    };
    anteriorChamberDepth?: {
      anteriorChamberDepth: number; // mm
      sourceOfAnteriorChamberDepthData: DataSource;
    };
    refractiveState?: {
      sphericalLensPower: number; // diopters
      cylinderLensPower: number;  // diopters
      cylinderAxis: number;       // degrees
      sourceOfRefractiveMeasurements: DataSource;
    };

    // Keratometry data used
    steepKeratometricAxis: KeratometricAxis;
    flatKeratometricAxis: KeratometricAxis;
    keratometryMeasurementType: "111754"; // Auto Keratometry
    keratopterIndex: number;

    // Alternative cornea measurements
    corneaMeasurements?: {
      steepCornealAxis: CornealAxis;
      flatCornealAxis: CornealAxis;
      corneaMeasurementMethod: CornealMeasurementMethod;
      keratopterIndex: number;
      refractiveIndexOfCornea?: number;     // For posterior measurements
      refractiveIndexOfAqueousHumor?: number; // For posterior measurements
      sourceOfCorneaMeasurementData: DataSource;
    };

    // Calculation details
    iolFormulaCode: IOLFormula;
    ophthalmicAxialLength: {
      ophthalmicAxialLength: number; // mm
      ophthalmicAxialLengthSelectionMethod: SelectionMethod;
      sourceOfOphthalmicAxialLength: DataSource;
    };
    surgicallyInducedAstigmatism?: {
      cylinderPower: number; // diopters
      cylinderAxis: number;  // degrees
    };

    // IOL specifications
    iolManufacturer: string;
    implantName: string;
    typeOfOpticalCorrection: "SPHERICAL" | "TORIC";
    lensConstant: LensConstant[];

    // Calculation results
    iolPower: IOLPowerResult[];
    iolPowerForExactEmmetropia?: number; // diopters
    toricIOLPowerForExactEmmetropia?: ToricPower;
    iolPowerForExactTargetRefraction?: number; // diopters (typically empty)
    toricIOLPowerForExactTargetRefraction?: ToricPower;
    calculationComment?: CalculationComment[];
  };

  // Left eye calculations (if performed)
  intraocularLensCalculationsLeftEye?: {
    // Same structure as right eye
  };
}
```

### IOL Calculation Results

```typescript
interface IOLPowerResult {
  iolPower: number; // diopters (spherical equivalent for toric)
  toricIOLPower?: {
    spherePower?: number;  // diopters (optional)
    cylinderPower: number; // diopters
    cylinderAxis: number;  // degrees
  };
  predictedRefractiveError: number; // diopters
  predictedToricError?: {
    spherePower?: number;  // diopters (optional)
    cylinderPower: number; // diopters
    cylinderAxis: number;  // degrees
  };
  implantPartNumber?: string;
  preSelectedForImplantation: "YES" | "NO"; // Only one should be "YES"
}
```

### IOL Formulas

```typescript
type IOLFormula =
  | "111760"          // Haigis
  | "111761"          // Haigis-L
  | "111762"          // Holladay 1
  | "111763"          // Holladay 2
  | "111764"          // Hoffer Q
  | "111767"          // SRK-T
  | "111860"          // Haigis Toric
  | "111861"          // Haigis-L Toric
  | "111862"          // Barrett Toric
  | "111863"          // Barrett True-K
  | "111864"          // Barrett True-K Toric
  | "111865"          // Barrett Universal II
  | "IOLM_BRRTT_TKT"  // Barrett TK Toric (private)
  | "IOLM_BRRTT_TKUII" // Barrett TK Universal II (private)
  | "IOLM_BRRTT_TKTK"  // Barrett TK True-K (private)
  | "IOLM_BRRTT_TKTKT"; // Barrett TK True-K Toric (private)
```

### Lens Constants

```typescript
interface LensConstant {
  conceptNameCode: LensConstantType;
  numericValue: string; // Encoded as string in DICOM
}

type LensConstantType =
  | "F-048FA"  // A-Constant
  | "111768"   // ACD Constant
  | "111769"   // Haigis a0
  | "111770"   // Haigis a1
  | "111771"   // Haigis a2
  | "111772"   // Hoffer pACD Constant
  | "111773"   // Surgeon Factor
  | "111866"   // Barrett Lens Factor
  | "111867";  // Barrett Design Factor
```

## Ophthalmic Photography IOD

### Scleral Reference Images

```typescript
interface ScleralImage {
  imageType: "ORIGINAL\\PRIMARY\\\\SCLERA";
  imageLaterality: "R" | "L";
  acquisitionContext: {
    toricAcquisitionQuality?: {
      valueType: "NUMERIC";
      numericValue: number; // Range 0.0-1.0
      measurementUnits: "1"; // No units
    };
    acquisitionExposureTime?: {
      valueType: "NUMERIC";
      numericValue: number; // milliseconds
      measurementUnits: "ms";
    };
    acquisitionIllumination?: {
      valueType: "NUMERIC";
      numericValue: number; // Range 0-255
      measurementUnits: "1"; // No units
    };
    referenceImageEvaluationData?: {
      valueType: "TEXT";
      textValue: string;
    };
    // Pixel dimensions
    pixelWidth: {
      valueType: "NUMERIC";
      numericValue: number; // millimeters
      measurementUnits: "mm";
    };
    pixelHeight: {
      valueType: "NUMERIC";
      numericValue: number; // millimeters
      measurementUnits: "mm";
    };
    // Limbus detection
    limbusCenterX: {
      valueType: "NUMERIC";
      numericValue: number; // pixels
      measurementUnits: "pixels";
    };
    limbusCenterY: {
      valueType: "NUMERIC";
      numericValue: number; // pixels
      measurementUnits: "pixels";
    };
    limbusRadius: {
      valueType: "NUMERIC";
      numericValue: number; // millimeters
      measurementUnits: "mm";
    };
    // Eyelid detection (polynomial coefficients)
    lowerLidCoeffA: number;
    lowerLidCoeffB: number;
    lowerLidCoeffC: number;
    upperLidCoeffA: number;
    upperLidCoeffB: number;
    upperLidCoeffC: number;
    scleraQuality: "SUCCESSFUL" | "WARNING" | "FAILED" | "NONE";
  };
}
```

### White-to-White Images

```typescript
interface WhiteToWhiteImage {
  imageType: "ORIGINAL\\PRIMARY\\\\WHITE_TO_WHITE";
  imageLaterality: "R" | "L";
  acquisitionContext: {
    wtwDiameter: {
      valueType: "NUMERIC";
      numericValue: number; // millimeters
      measurementUnits: "mm";
    };
    wtwFpX: {
      valueType: "NUMERIC";
      numericValue: number; // millimeters offset
      measurementUnits: "mm";
    };
    wtwFpY: {
      valueType: "NUMERIC";
      numericValue: number; // millimeters offset
      measurementUnits: "mm";
    };
    pupilDiameter: {
      valueType: "NUMERIC";
      numericValue: number; // millimeters
      measurementUnits: "mm";
    };
    pupilFpX: {
      valueType: "NUMERIC";
      numericValue: number; // millimeters offset
      measurementUnits: "mm";
    };
    pupilFpY: {
      valueType: "NUMERIC";
      numericValue: number; // millimeters offset
      measurementUnits: "mm";
    };
    positionFpX: {
      valueType: "NUMERIC";
      numericValue: number; // pixels
      measurementUnits: "pixels";
    };
    positionFpY: {
      valueType: "NUMERIC";
      numericValue: number; // pixels
      measurementUnits: "pixels";
    };
    wtwQuality: "SUCCESSFUL" | "WARNING" | "FAILED" | "NONE";
  };
}
```

## Quality Control Images

### Multi-frame Secondary Capture Images

```typescript
interface QualityControlImage {
  imageType: "DERIVED\\PRIMARY\\\\OAM_QUALITY" | "DERIVED\\PRIMARY\\\\KER_QUALITY";
  qualityControlImage: "YES";
  referencedInstance: {
    referencedSOPClassUID: string; // References measurement SOP Class
    referencedSOPInstanceUID: string;
    purposeOfReference: "MEASUREMENTS"; // Private code
  };
  numberOfFrames: number;
  frameIncrementPointer: "(0018,2002)"; // Frame Label Vector
  frameLabelVector: string[]; // Frame numbers as labels
}
```

## Common Data Types

### Data Source Types

```typescript
type DataSource =
  | "111780"         // Measurement From This Device
  | "113857"         // Manual Entry
  | "IOLM_SCAN_000"  // Measurement at scan angle 0Â° (private)
  | "IOLM_SCAN_030"  // Measurement at scan angle 30Â° (private)
  | "IOLM_SCAN_090"  // Measurement at scan angle 90Â° (private)
  | "IOLM_SCAN_240"  // Measurement at scan angle 240Â° (private)
  | "IOLM_SCAN_300"  // Measurement at scan angle 300Â° (private)
  | "IOLM_SCAN_330"  // Measurement at scan angle 330Â° (private)
  | "IOLM_COMPOSITE"; // Calculated composite result (private)
```

### Lens Status Types

```typescript
type LensStatus =
  | "DA-73410"           // Aphakic
  | "R-2073F"            // Phakic
  | "A-040F7"            // Phakic IOL
  | "F-02087"            // Piggyback IOL
  | "DA-73460"           // Pseudophakia
  | "PGGYBCK_SILICON"    // Piggyback Silicone IOL (private)
  | "PSDPHKC_SILICON"    // Pseudophakic Silicone (private)
  | "PSDPHKC_PMMA";      // Pseudophakic PMMA (private)
```

### Vitreous Status Types

```typescript
type VitreousStatus =
  | "DA-7930D"  // Post-Vitrectomy
  | "F-035FD"   // Silicone Oil
  | "T-AA092";  // Vitreous Only
```

### Refractive Surgery Types

```typescript
type RefractiveSurgeryType =
  | "P1-A3102"  // RK (Radial Keratotomy)
  | "P1-A3835"  // PRK
  | "P0-0526F"  // LASIK
  | "P1-A3846"; // LASEK
```

### Refractive Error Types

```typescript
type RefractiveErrorType =
  | "DA-74120"  // Myopia
  | "DA-74110"; // Hyperopia
```

## Instance Relationships

All instances from a single IOLMaster 700 examination are linked through:

### Shared Identifiers

```typescript
interface SharedIdentifiers {
  // Links all instances from one examination
  performedProcedureStepID: string;
  performedProcedureStepStartDate: string; // YYYYMMDD
  performedProcedureStepStartTime: string; // HHMMSS
  performedProcedureStepDescription: "Ophthalmic Biometry Measurement";

  // Patient and study identifiers
  studyInstanceUID: string;
  patientID: string;
  patientsName: string;
}
```

### Instance Cross-References

```typescript
interface InstanceReferences {
  // From Encapsulated PDF to other instances
  sourceInstanceSequence: {
    referencedSOPClassUID: string;
    referencedSOPInstanceUID: string;
  }[];

  // From Quality Control Images to Measurements
  referencedInstance: {
    referencedSOPClassUID: string;
    referencedSOPInstanceUID: string;
    purposeOfReference: "MEASUREMENTS";
  };

  // From Measurements to Quality Control Images
  referencedOphthalmicAxialLengthMeasurementQCImage?: {
    referencedSOPClassUID: "1.2.840.10008.5.1.4.1.1.7.2";
    referencedSOPInstanceUID: string;
    referencedFrameNumber: number;
  };
}
```

## Private Extensions

IOLMaster 700 uses several private tag groups for extended functionality:

### Private Tag Groups

| Group | Creator | Purpose |
|-------|---------|---------|
| (771B,00xx) | "99CZM" | PDF measurement values |
| (1201,00xx) | "99CZM_IOLMaster_ExtendedKeratometryMeasurements" | Extended keratometry |
| (1203,00xx) | "99CZM_IOLMaster_ClinicalPatientInformation" | Clinical data |
| (1205,00xx) | "99CZM_IOLMaster_ExtendedOphthalmicAxialMeasurements" | Extended axial measurements |
| (2201,00xx) | "99CZM_NIM_INTERNAL_01" | Internal metadata |

These private tags provide additional measurement details and quality metrics not available in standard DICOM tags.

## Related Documentation

- [IOLMaster 700 Import Adapter](../Import/ZeissIOLMaster700.md) â€“ Implementation details
- [DICOM Integration Guide](../../Operations/Integration.md) â€“ Setup and configuration
- [Measurement Types](../../API/Events.md) â€“ DATEYE measurement schema
- [Import Adapter API](../ImportAPI.md) â€“ Adapter interface specification



FILE: ../development/README.md
==================================================

# Development Documentation

**DATEYE** development resources and implementation status.

## Quick Start

- **ğŸ“‹ [Technical Implementation Guide](TECHNICAL-GUIDE.md)** - Complete development status and implementation details

## Current Status

**Project Completion**: 40% - Export architecture and integration remaining

### âœ… Production Ready Components

- **Import Infrastructure**: Complete ImportAdapter pattern with Topcon MYAH reference implementation
- **Core Architecture**: Clean Architecture with three-layer separation
- **State Management**: BLoC/Cubit pattern infrastructure
- **Storage Framework**: NDJSON file structure and database abstraction defined

### âŒ Remaining Work (3-4 weeks)

- **Export Architecture**: Complete IExportAdapter implementation and AL550 adapter
- **Dependency Injection**: Fix code generation and adapter registration
- **End-to-End Pipeline**: Import â†’ Storage â†’ Export integration
- **UI Workflow**: Source â†’ Target connection management interface
- **Security Layer**: AES-256 patient data encryption for production

## Architecture Overview

The DATEYE platform implements a proven **ImportAdapter/ExportAdapter** pattern that provides:

- **Modularity**: Independent device integrations with standardized interfaces
- **Scalability**: Add new devices without affecting existing functionality
- **Maintainability**: Clear separation of concerns with dependency injection
- **Reliability**: Comprehensive error handling with Either pattern

## Key Implementation Files

| Component | Location | Status |
|-----------|----------|---------|
| Import Interface | `lib/infrastructure/adapters/i_import_adapter.dart` | âœ… Complete |
| Export Interface | `lib/infrastructure/adapters/i_export_adapter.dart` | âœ… Complete |
| Topcon MYAH | `lib/infrastructure/adapters/topcon_myah_import_adapter.dart` | âœ… Production Ready |
| AL550 Export | `lib/infrastructure/adapters/al550/al550_export_adapter.dart` | âœ… Production Ready |
| Storage System | `lib/infrastructure/storage/` | âœ… Complete |
| State Management | `lib/presentation/bloc/` | âœ… Complete |

## Development Workflow

1. **Architecture Review**: Study the ImportAdapter/ExportAdapter pattern
2. **Environment Setup**: Flutter development environment with dependencies
3. **Implementation**: Follow established patterns for new device integrations
4. **Testing**: Validate adapters with device-specific test data
5. **Integration**: Connect adapters through the storage and state management layers

## Getting Started

For complete implementation details, system architecture, and development guidelines, see the **[Technical Implementation Guide](TECHNICAL-GUIDE.md)**.



FILE: ../development/IMPLEMENTATION-ROADMAP.md
==================================================

# DATEYE Implementation Roadmap

## Current Reality Check

**Actual Completion**: ~40% (not 95% as previously stated)
**Core Issue**: Export architecture completely missing, dependency injection broken

## Immediate Fixes Required (Day 1)

### 1. Fix Dependency Injection (30 minutes)

```bash
cd repository
dart run build_runner build
```

**Issue**: `injection.config.dart` missing - app cannot start
**Fix**: Code generation creates missing DI configuration
**Verification**: Check that `lib/injection.config.dart` exists after build

### 2. Validate Import Pipeline (2 hours)

**Test Current Implementation**:
```bash
# Place test file in import directory
# Verify ImportAdapter can parse Topcon MYAH files
# Check if storage system actually works
```

**Critical**: Confirm what actually works vs. what's just framework

## Priority 1: Export Architecture Foundation (Week 1-2)

### Phase 1A: IExportAdapter Interface (Day 1-2)

**File**: `lib/infrastructure/adapters/i_export_adapter.dart`

```dart
import 'package:dateye/core/errors/failures.dart';
import 'package:dateye/core/entities/export/exportable_data_file.dart';
import 'package:dateye/core/entities/export/export_destination.dart';
import 'package:fpdart/fpdart.dart';

/// Export result model
@freezed
class ExportResult with _$ExportResult {
  const factory ExportResult.success({
    String? message,
    int? exportedCount,
    Map<String, dynamic>? metadata,
  }) = ExportSuccess;

  const factory ExportResult.failure({
    required String error,
    String? errorCode,
    bool retryable = true,
  }) = ExportFailure;
}

/// Interface for export adapters - mirrors ImportAdapter pattern exactly
abstract class IExportAdapter {
  /// Unique adapter identifier
  String get id;

  /// Human-readable display name
  String get displayName;

  /// Test if adapter can connect to target
  Future<Either<Failure, bool>> testConnection(ExportDestination target);

  /// Export data to target
  Future<Either<Failure, ExportResult>> export({
    required ExportableDataFile data,
    required ExportDestination target,
  });

  /// Configuration schema for UI generation (optional)
  Map<String, dynamic> get configSchema => {};

  /// Validate configuration
  Either<Failure, Unit> validateConfig(Map<String, dynamic> config) {
    return const Right(unit);
  }
}
```

**Architecture Decision**: Exactly mirror ImportAdapter pattern for consistency

### Phase 1B: AL550 Export Adapter (Day 3-5)

**File**: `lib/infrastructure/adapters/al550_export_adapter.dart`

```dart
@Named('al550_export')
@Singleton(as: IExportAdapter)
class AL550ExportAdapter implements IExportAdapter {
  const AL550ExportAdapter(this._httpClient);

  final IHttpClient _httpClient;

  @override
  String get id => 'al550_export';

  @override
  String get displayName => 'Mediworks AL550';

  @override
  Map<String, dynamic> get configSchema => {
    'type': 'object',
    'required': ['host', 'port'],
    'properties': {
      'host': {
        'type': 'string',
        'title': 'Device IP Address',
        'pattern': r'^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$',
      },
      'port': {
        'type': 'integer',
        'title': 'Port',
        'default': 8080,
        'minimum': 1,
        'maximum': 65535,
      },
    },
  };

  @override
  Future<Either<Failure, bool>> testConnection(ExportDestination target) async {
    try {
      final host = target.config['host'] as String;
      final port = target.config['port'] as int;

      final response = await _httpClient.get(
        'http://$host:$port/getPatients',
        options: HttpRequestOptions(connectTimeout: Duration(seconds: 5)),
      );

      return Right(response.statusCode == 200);
    } catch (e) {
      return Left(NetworkFailure('AL550 connection failed: $e'));
    }
  }

  @override
  Future<Either<Failure, ExportResult>> export({
    required ExportableDataFile data,
    required ExportDestination target,
  }) async {
    // Implementation following Mediworks API documentation
    // See: docs/external-apis/mediworks/setPatients-en.md
  }
}
```

**Implementation Notes**:
- Follow exact same DI pattern as TopconMyahImportAdapter
- Use HTTP client from existing infrastructure
- Reference Mediworks API documentation in `/docs/external-apis/mediworks/`

### Phase 1C: Export Service Integration (Day 6-7)

**Fix**: `lib/infrastructure/datasources/exporting_datasource.dart`

Replace all `UnimplementedError()` with actual adapter integration:

```dart
@Singleton(as: ExportingDatasource)
class ExportingDatasourceImpl implements ExportingDatasource {
  const ExportingDatasourceImpl(this._adapters, this._database);

  final Map<String, IExportAdapter> _adapters;
  final IDatabase _database;

  @override
  Future<Either<Failure, Unit>> exportToTarget(ExportableDataFile data) async {
    final adapter = _adapters[data.destination.adapterId];
    if (adapter == null) {
      return Left(AdapterNotFoundFailure(data.destination.adapterId));
    }

    final result = await adapter.export(data: data, target: data.destination);

    // Log export result
    return result.fold(
      (failure) => Left(failure),
      (success) => Right(unit),
    );
  }
}
```

### Phase 1D: Adapter Registration (Day 8)

**File**: Update DI modules to register export adapters

```dart
// Add to injection configuration
@module
abstract class ExportAdapterModule {
  @singleton
  Map<String, IExportAdapter> get exportAdapters => {
    'al550_export': getIt<IExportAdapter>(instanceName: 'al550_export'),
    // Future adapters will be added here
  };
}
```

## Priority 2: End-to-End Pipeline (Week 2-3)

### Phase 2A: Import â†’ Export Connection (Day 9-11)

**Goal**: Make import trigger automatic export

**Implementation**:
1. Import completes â†’ save to storage
2. Check for configured export destinations
3. Create ExportableDataFile
4. Trigger export via ExportService
5. Log complete workflow

### Phase 2B: UI Integration (Day 12-14)

**Goal**: UI for configuring "Source â†’ Target" workflows

**Components**:
- Connection management screen
- Device discovery integration
- Export target configuration forms
- Real-time status monitoring

## Priority 3: Additional Export Adapters (Week 3-4)

### File Export Adapter (Day 15-16)
- JSON/CSV output to filesystem
- Configurable output formats
- Batch export capabilities

### Myopia.cloud Adapter (Day 17-18)
- Cloud API integration
- Data anonymization
- Upload with retry logic

## Priority 4: Testing & Validation (Week 4)

### End-to-End Testing (Day 19-20)
- Import â†’ Storage â†’ Export pipeline
- Error handling validation
- Performance testing with real data

## Development Guidelines

### Architecture Consistency Rules

1. **Symmetrical Pattern**: Export adapters MUST mirror import adapter patterns exactly
2. **DI Registration**: Use identical `@Named` and `@Singleton` patterns
3. **Error Handling**: Consistent `Either<Failure, T>` pattern throughout
4. **File Structure**: Mirror import adapter directory structure

### Implementation Order

**Critical**: Follow this exact sequence to avoid dependency issues:

1. Fix DI first (app must start)
2. Implement IExportAdapter interface
3. Create one reference adapter (AL550)
4. Integrate with existing export service
5. Test end-to-end before adding more adapters

### Testing Strategy

**Each Phase**: Implement, test, document before moving to next phase
**Integration Points**: Verify DI registration after each adapter
**End-to-End**: Full import â†’ export pipeline test with real data

## Validation Checkpoints

### Week 1 Checkpoint
- [ ] DI container initializes without errors
- [ ] IExportAdapter interface complete
- [ ] AL550ExportAdapter compiles and registers
- [ ] Export service integrates with adapters
- [ ] Simple export operation succeeds

### Week 2 Checkpoint
- [ ] Import triggers automatic export
- [ ] UI can configure export destinations
- [ ] Error handling works end-to-end
- [ ] Status monitoring shows real progress

### Week 3 Checkpoint
- [ ] Multiple export adapters working
- [ ] File export functionality complete
- [ ] Cloud export integration functional
- [ ] Performance meets requirements

### Final Checkpoint
- [ ] Complete import â†’ export workflows
- [ ] All adapters tested with real devices
- [ ] Documentation updated with actual implementation
- [ ] Ready for medical practice deployment

## Risk Mitigation

### High-Risk Areas

1. **HTTP Client Integration**: Existing HTTP client may need adaptation for AL550 API
2. **Data Model Compatibility**: ExportableDataFile may need schema updates
3. **File Watching**: Storage system file watching is untested
4. **Memory Management**: NDJSON operations with large datasets

### Mitigation Strategies

1. **Start Small**: Test with minimal data sets first
2. **Incremental Testing**: Validate each component individually
3. **Fallback Plans**: Manual export if automatic fails
4. **Documentation**: Update docs with actual findings, not assumptions

## Success Metrics

- **Functional**: End-to-end import â†’ export pipeline operational
- **Performance**: Process 100 patient records in <30 seconds
- **Reliability**: <1% failure rate for well-configured devices
- **Usability**: Non-technical users can configure connections in <5 minutes

---

**Next Action**: Fix dependency injection and validate what currently works before implementing new features.



FILE: ../development/DEVELOPER-QUICK-REFERENCE.md
==================================================

# Developer Quick Reference

## Current Implementation Reality

| Component | Status | Location | Action Required |
|-----------|--------|----------|-----------------|
| **ImportAdapter** | âœ… Working | `lib/infrastructure/adapters/i_import_adapter.dart` | None - use as reference |
| **Topcon MYAH** | âœ… Working | `lib/infrastructure/adapters/topcon_myah_import_adapter.dart` | None - production ready |
| **IExportAdapter** | âŒ Missing | NOT IMPLEMENTED | **CREATE INTERFACE** |
| **AL550 Export** | âŒ Missing | NOT IMPLEMENTED | **CREATE ADAPTER** |
| **Export Service** | âš ï¸ Stubs only | `lib/infrastructure/datasources/exporting_datasource.dart` | **IMPLEMENT METHODS** |
| **Dependency Injection** | âŒ Broken | `injection.config.dart` missing | **RUN BUILD_RUNNER** |

## Critical First Steps

### 1. Fix DI (5 minutes)
```bash
cd repository
dart run build_runner build
```
**Why**: App cannot start without generated DI config

### 2. Verify What Works (30 minutes)
```bash
# Test current import functionality
# Place MYAH test file in import directory
# Verify parsing actually works
```

### 3. Implement Export Architecture (1-2 weeks)
**Priority Order**:
1. IExportAdapter interface
2. AL550ExportAdapter reference implementation
3. Export service integration
4. End-to-end pipeline testing

## Architecture Rules (CRITICAL)

### Symmetrical Pattern Requirement
```dart
// ImportAdapter (REFERENCE - copy this pattern exactly)
@Named('topcon_myah')
@Singleton(as: ImportAdapter)
class TopconMyahImportAdapter implements ImportAdapter

// ExportAdapter (IMPLEMENT - mirror the pattern)
@Named('al550_export')
@Singleton(as: IExportAdapter)
class AL550ExportAdapter implements IExportAdapter
```

### Error Handling Consistency
```dart
// Always use Either pattern
Future<Either<Failure, Result>> methodName()

// Never use exceptions for business logic
// Never return null for failures
```

### File Structure Mirror
```
lib/infrastructure/adapters/
â”œâ”€â”€ import/
â”‚   â”œâ”€â”€ i_import_adapter.dart âœ…
â”‚   â””â”€â”€ topcon_myah_import_adapter.dart âœ…
â””â”€â”€ export/
    â”œâ”€â”€ i_export_adapter.dart âŒ CREATE THIS
    â””â”€â”€ al550_export_adapter.dart âŒ CREATE THIS
```

## Implementation Template

### IExportAdapter Interface Template
```dart
// File: lib/infrastructure/adapters/i_export_adapter.dart
import 'package:dateye/core/errors/failures.dart';
import 'package:fpdart/fpdart.dart';

abstract class IExportAdapter {
  String get id;
  String get displayName;

  Future<Either<Failure, bool>> testConnection(ExportDestination target);
  Future<Either<Failure, ExportResult>> export({
    required ExportableDataFile data,
    required ExportDestination target,
  });
}
```

### AL550 Adapter Template
```dart
// File: lib/infrastructure/adapters/al550_export_adapter.dart
@Named('al550_export')
@Singleton(as: IExportAdapter)
class AL550ExportAdapter implements IExportAdapter {
  const AL550ExportAdapter(this._httpClient);
  final IHttpClient _httpClient;

  @override
  String get id => 'al550_export';

  @override
  String get displayName => 'Mediworks AL550';

  // Implement testConnection and export methods
  // Follow Mediworks API docs in /docs/external-apis/mediworks/
}
```

## Common Pitfalls

### âŒ Don't Do This
```dart
// Inconsistent pattern
class ExportService {
  switch (type) {
    case 'al550': return exportToAL550();
  }
}

// Direct exceptions
throw Exception('Failed');

// Missing DI registration
// (adapter won't be found)
```

### âœ… Do This
```dart
// Consistent adapter pattern
@Named('device_name')
@Singleton(as: IExportAdapter)

// Either pattern
return Left(NetworkFailure('Connection failed'));

// Proper DI registration
final adapter = getIt<IExportAdapter>(instanceName: 'al550_export');
```

## Testing Strategy

### Test Each Layer
```dart
// 1. Adapter unit test
test('AL550ExportAdapter exports patient successfully')

// 2. Service integration test
test('ExportService routes to correct adapter')

// 3. End-to-end test
test('Import file â†’ process â†’ export to AL550')
```

### Test Data Requirements
- Mock HTTP responses for AL550 API
- Sample patient data matching ImportedDataFileModel
- Error scenarios (network failures, invalid data)

## Documentation Update Requirements

When implementing:
1. Update completion percentages (currently wrong)
2. Change "Complete" to "Implemented" in docs
3. Add actual file paths and status
4. Document any architecture deviations

## Success Criteria

### Week 1 Target
- [ ] DI container initializes successfully
- [ ] IExportAdapter interface compiles
- [ ] AL550ExportAdapter registers with DI
- [ ] Export service calls adapter (even if adapter is stubbed)

### Week 2 Target
- [ ] AL550ExportAdapter can connect to real device
- [ ] Simple patient export works end-to-end
- [ ] Error handling works for network failures

### Production Ready
- [ ] Import â†’ Export pipeline works automatically
- [ ] UI can configure export destinations
- [ ] Multiple export adapters working
- [ ] Performance acceptable (100 patients in <30 seconds)

## Quick Help

**Build Issues**: `dart run build_runner build --delete-conflicting-outputs`
**DI Issues**: Check @Named annotations match getIt calls exactly
**HTTP Issues**: Use existing IHttpClient, don't create new one
**API Issues**: Reference `/docs/external-apis/mediworks/` for AL550 specs

**Architecture Questions**: Mirror ImportAdapter pattern exactly - no exceptions!



==================================================
END OF DOCUMENTATION
Total files: 35
Generated: 2025-07-13 07:07